<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Pod Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wepod.github.io/"/>
  <updated>2019-12-17T08:47:00.888Z</updated>
  <id>https://wepod.github.io/</id>
  
  <author>
    <name>Ata Gülalan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>POD | Prototip -1</title>
    <link href="https://wepod.github.io/blog/Prototip-1/"/>
    <id>https://wepod.github.io/blog/Prototip-1/</id>
    <published>2019-12-17T10:21:33.000Z</published>
    <updated>2019-12-17T08:47:00.888Z</updated>
    
    <content type="html"><![CDATA[<p>Prototip -1</p><a id="more"></a><h4 id="Pod-Prototip-1"><a href="#Pod-Prototip-1" class="headerlink" title="Pod | Prototip -1"></a>Pod | Prototip -1</h4><p>Prototipimizi <strong>Figma</strong> üzerinden yaptığımızı daha önceden söylemiştik.</p><blockquote><p>Figma’nın ne olduğunu ve nasıl çalıştığını merak ediyorsanız, <a href="https://wepod.github.io/blog/Figma">buradan</a> <strong>Figma</strong> adlı başlığımıza ulaşabilirsiniz.</p></blockquote><p>Prototipin başlangıcında oluşturacağımız sayfaları uygulama ve kullanıcı açısından grupladık. Daha sonra bunları açarak, aşağıdaki ekran sayfalarını oluşturduk;</p><ul><li>Yükleme Ekranı</li><li>Başlangıç Ekranı</li><li>Harita Ekranı</li><li>Bölümler Ekranı</li><li>Bölüm Ekranı</li><li>Editör Ekranı</li><li>Bitiş Ekranı</li><li>Giriş Yap Ekranı</li><li>Kayıt Ol Ekranı</li><li>Destek Ekranı</li><li>Nasıl Oynanır? Ekranı</li><li>Amacımız Ekranı</li></ul><h4 id="Yukleme-Ekrani"><a href="#Yukleme-Ekrani" class="headerlink" title="Yükleme Ekranı"></a>Yükleme Ekranı</h4><p>Yükleme ekranı oyunun açıldığından başlamaya hazır olduğu bölümü kapsamaktadır. Prototipte bu bölüm için dört ekran bulunmaktadır. Yavaş geçiş ile <strong>yüklenme efekti</strong> izlenimi verilmiştir.<br><img src="/blog/Prototip-1/yukleme-ekrani.png" alt="Yükleme Ekranı" title="Yükleme Ekranı"></p><h4 id="Baslangic-Ekrani"><a href="#Baslangic-Ekrani" class="headerlink" title="Başlangıç Ekranı"></a>Başlangıç Ekranı</h4><p>Başlangıç ekranında kullanıcı birçok işlem yapabilir. Buradaki metinlerle <strong>beş</strong> farklı ekrana geçiş yapabilir. Kullanıcı;</p><ul><li>Başla butonu ile oyuna başlayabilir,</li><li>Nasıl oynanır butonu ile oyunun nasıl oynandığını anlatan ekrana erişebilir,</li><li>Hesabım var butonu ile hesabına giriş yapabilir,</li><li>Destek butonundan destek sayfasına erişebilir,</li><li>Ya da amacımız butonu ile uygulamanın neden yapıldığını anlatan amacımız sayfasını görüntüleyebilir.</li></ul><p><img src="/blog/Prototip-1/baslangic-ekrani.png" alt="Başlangıç Ekranı" title="Başlangıç Ekranı"></p><h4 id="Harita-Ekrani"><a href="#Harita-Ekrani" class="headerlink" title="Harita Ekranı"></a>Harita Ekranı</h4><p>Oyunun bölümlerinin grupça bulunduğu ekrandır.</p><blockquote><p>Oyun bölümlerini ağacın yaprak ve dallarına benzetirsek, aynı özellikteki bölümlerin bulunduğu grup bir ağaç, ağaçların bulunduğu büyük gruba da orman benzetmesi yapmış oluruz. Bu şekilde çocuklara <strong>pozitif</strong> bir mesaj da vermeyi hedefledik.</p></blockquote><p>Bu ekranda üç çeşit olmak üzere toplam altı ormanımız bulunuyor. Bunlar;</p><ul><li>Belgrad</li><li>Redwood</li><li>Monteverde</li><li>Jiuzhaigou</li><li>Great Bear</li><li>Crooked</li></ul><p><img src="/blog/Prototip-1/harita-ekrani.png" alt="Harita Ekranı" title="Harita Ekranı"></p><h4 id="Bolumler-Ekrani"><a href="#Bolumler-Ekrani" class="headerlink" title="Bölümler Ekranı"></a>Bölümler Ekranı</h4><p>Bölümlerin bir arada bulunduğu, <strong>ağaç</strong> benzetmesini yaptığımız sayfa bu ekrandadır. İçinde bir bölüm bulunsa da şu an mevcut <strong>üç farklı ağaç tipi</strong>miz vardır.</p><p><img src="/blog/Prototip-1/bolumler-ekrani.png" alt="Bölümler Ekranı" title="Bölümler Ekranı"></p><h4 id="Bolum-Editor-Bitis-Ekranlari"><a href="#Bolum-Editor-Bitis-Ekranlari" class="headerlink" title="Bölüm - Editör - Bitiş Ekranları"></a>Bölüm - Editör - Bitiş Ekranları</h4><blockquote><p>Bu ekranlar birbiriyle etkileşimli olduğundan tek başlık altında anlatmak istiyoruz.</p></blockquote><p>Kullanıcının oyunu oynadığı bölümdür. Ağaçtan seçtiği yaprak ile ilgili bölümü açar. Şu an mevcut bir oyunumuz bulunuyor.</p><p>Bölümümüzde kullanıcıdan verilen bir dizi kutuların karşı tarafa yani çıkış bölümüne sırayla iletilmesi isteniyor. Kullanıcı bölümün alt kısmında bulunan ok ile <strong>editör sayfası</strong>nı açıp ilgili <strong>mantıksal sistemi</strong> kurması gerekiyor. Kullanıcı algoritmayı kurduktan sonra küçük arkadaşımız kutuları sırasıyla karşı tarafa iletmeye başlıyor.</p><p>Kullanıcı bölümü bitirdiğinde karşısına bitiş ekranı geliyor. Burada performansı ve kazandığı puan gibi bilgiler kullanıcıya gösteriliyor.<br>Kullanıcı devam et diyerek sonraki bölüme geçiş yapabilir.</p><p><img src="/blog/Prototip-1/multiple-ekran.png" alt="Bölüm - Editör - Bitiş Ekranları" title="Bölüm - Editör - Bitiş Ekranları"></p><h4 id="Giris-Yap-Kayit-Ol-Ekranlari"><a href="#Giris-Yap-Kayit-Ol-Ekranlari" class="headerlink" title="Giriş Yap - Kayıt Ol Ekranları"></a>Giriş Yap - Kayıt Ol Ekranları</h4><p>Kullanıcı başlangıçta hesabım var butonu ile giriş yapma ekranına ulaşabileceğini söylemiştik. Bu ekranda kullanıcı;</p><ul><li>Oyuna kayıt olduğu e-posta ve şifresi ile hesabına giriş yapabilir,</li><li>Cihazın hesabını tanıması için beni hatırla butonuna tıklayabilir,</li><li>Şifremi unuttum butonu ile şifresini kurtarabilir,</li><li>Veya kayıt ol butonu ile oyuna kayıt olabilir.</li></ul><h4 id="Nasil-Oynanir-Amacimiz-Ekranlari"><a href="#Nasil-Oynanir-Amacimiz-Ekranlari" class="headerlink" title="Nasıl Oynanır? - Amacımız Ekranları"></a>Nasıl Oynanır? - Amacımız Ekranları</h4><p>Kullanıcı bu iki ekrana da başlangıç ekranından ilgili butonlara tıklayarak ulaşabilmektedir.</p><p>Nasıl oynanır ekranında, kullanıcıya onunun nasıl oynanıldığı, oyunun fiziksel ve mantıksal mekaniği anlatılmaktadır.</p><p>Amacımız ekranında ise bizim uygulamayı neden yaptığımız, amacımızın ve hedeflerimizin ne olduğu ile ilgili metinler bulunmaktadır.</p><p><img src="/blog/Prototip-1/multiple-ekran2.png" alt="Bölüm - Editör - Bitiş Ekranları" title="Bölüm - Editör - Bitiş Ekranları"></p><h4 id="Figma-Onizleme"><a href="#Figma-Onizleme" class="headerlink" title="Figma Önizleme"></a>Figma Önizleme</h4><p>Buradan protipi inceleyebilir ve devamında yapacağımız değişiklikleri ve güncellemeleri takip edebilirsiniz.</p><iframe src="https://www.figma.com/embed?embed_host=share&url=https%3A%2F%2Fwww.figma.com%2Fproto%2F1BO43LpuV9KIt6UcbDx6y2%2FPOD-Prototype%3Fnode-id%3D12%253A167%26scaling%3Dscale-down" frameborder="0" style="overflow:hidden;height:800px;width:100%;"></iframe><p>Düzgün görüntülenmiyorsa <a href="https://www.figma.com/proto/1BO43LpuV9KIt6UcbDx6y2/POD-Prototype?node-id=3%3A60&scaling=scale-down" target="_blank" rel="noopener">buraya tıklayın</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Prototip -1&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="atagulalan" scheme="https://wepod.github.io/tags/atagulalan/"/>
    
      <category term="oguzturker8" scheme="https://wepod.github.io/tags/oguzturker8/"/>
    
      <category term="stunali" scheme="https://wepod.github.io/tags/stunali/"/>
    
  </entry>
  
  <entry>
    <title>EcmaScript6 ile gelen değişiklikler</title>
    <link href="https://wepod.github.io/blog/es6/"/>
    <id>https://wepod.github.io/blog/es6/</id>
    <published>2019-12-01T22:14:56.000Z</published>
    <updated>2019-12-17T08:47:00.892Z</updated>
    
    <content type="html"><![CDATA[<p>Bu yazıda EcmaScript6 ile gelen değişiklikler üzerinde duruldu</p><a id="more"></a><h2 id="EcmaScript-Nedir"><a href="#EcmaScript-Nedir" class="headerlink" title="EcmaScript Nedir ?"></a>EcmaScript Nedir ?</h2><p>Zaman içerisinde JavaScript birçok evrim geçirdi.İlk zamanlarda Javascript EcmaScript ismini almıştı.Artık EcmaScript JavaScript’in kurallarını belirleyen standart haline geldi.EcmaScript6 Haziran 2015`te yayınlandı<br>EcmaScript6 ile birlikte kod yazmayı kolaylaştıran birçok yenilik geldi.</p><p><strong>Const ve Let</strong></p><p>EcmaScript2015 `te değişkenleri sadece var ile tanımlayabiliyorduk.EcmaScript6 ile gelen yenilikler ile const ve let aracılığı ile değişkenlerimizi tanımlayabiliriz.</p><pre><code>const PI = 3.141593 let name=&quot;Serdar&quot;</code></pre><p> <strong>Block Scope and Variables and  Functions</strong> </p><p>EcmaScript6’den önce değişkenler fonksiyon scoped`tu.EcmaScript6 ile birlikte gelen güncelleme ile let ve const ile tanımlanan değişkenler blok scope oldu.</p><p> <strong>Arrow Functions</strong></p><p>EcmaScript6 ile birlikte fonksiyon tanımına yeni bir sözdizimi getirildi.Artık daha kısa bir sözdizimi ile fonksiyon tanımlayabiliriz.</p><p><code>hello = () =&gt; {  return  &quot;Hello World!&quot;;  }</code></p><p> <strong>Varsayılan Fonksiyon Parametleri</strong></p><p>EcmaScript6 ile gelen özelliklerden bir taneside artık fonksiyonlarda varsayılan parametler kullanabiliriz.</p><pre><code>function multiply(a, b = 1) {  return a * b;}console.log(multiply(5, 2));// expected output: 10console.log(multiply(5));// expected output: 5</code></pre><p><strong>Class sözdizimi</strong></p><p>ES6 ile gelen yeniliklerden bir taneside class sözdizimi.Java , C++ , C# dillerinde olduğu gibi class anahtar kelimesini kullanarak sınıf oluşturabiliyoruz.</p><pre><code>class Polygon {  constructor(height, width) {    this.area = height * width;  }}console.log(new Polygon(4,3).area);// expected output: 12</code></pre><p><strong>Kalıtım</strong></p><p>EcmaScript6 ile gelen yenilikle birlikte diğer dillerde olduğu gibi (Java,C#,C++) extends anahtar kelimesi kullanılarak kalıtım yapılabilir.</p><pre><code>class Animal {   constructor(name) {    this.name = name;  }  speak() {    console.log(this.name + &apos; makes a noise.&apos;);  }}class Dog extends Animal {  speak() {    console.log(this.name + &apos; barks.&apos;);  }}</code></pre><p><strong>Promise</strong> </p><p>JavaScript asenkron çalışan bir programlama dilidir.EcmaScript6dan önce callback fonksiyonları ile asenkron fonksiyonları yönetiyorduk.EcmaScript6 ile birlikte asenkron fonksiyonlar promise sözdizimi ile yönetilmeye başladı.</p><pre><code>new Promise(function(resolve, reject) { ... });</code></pre><p> <strong>Destructing</strong><br>EcmaScript6 ile birlikte Destructing özelliğide gelmiştir.Destructing sayesinde dizileri ve objeleri daha kolay bir şekilde parçalara ayırabiliyoruz.Bu sayede daha okunabilir kod yazabiliriz.</p><pre><code>var a, b, rest;[a, b] = [10, 20];console.log(a);// expected output: 10console.log(b);// expected output: 20[a, b, ...rest] = [10, 20, 30, 40, 50];console.log(rest);// expected output: [30,40,50]</code></pre><p><strong>Template Literal</strong></p><p>Template literals stringleri deklarasyon etmek için yeni bir yol sağlıyor.`` (backstick) içersine yazdığınız ${} sayesinde stringler üzerinde istediğiniz işlemleri yapabilirsiniz.</p><pre><code>`string text``string text line 1 string text line 2``string text ${expression} string text`tag `string text ${expression} string text`</code></pre><p><strong>Find()</strong><br>Array.Find()  methodu test fonksiyonunu karşılayan ilk elamanı döndürür.</p><pre><code>const array1 = [5, 12, 8, 130, 44];const found = array1.find(element =&gt; element &gt; 10);</code></pre><p> <strong>findIndex()</strong><br>Array.FindIndex()  methodu test fonksiyonunu karşılayan ilk elamanının index değerini döndürür.</p><pre><code>arr.findIndex(callback[, thisArg])</code></pre><p>Kaynaklar : <a href="https://developer.mozilla.org/tr/docs/Web/JavaScript" target="_blank" rel="noopener">JavaScript - MDN - Mozilla</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Bu yazıda EcmaScript6 ile gelen değişiklikler üzerinde duruldu&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="stunali" scheme="https://wepod.github.io/tags/stunali/"/>
    
  </entry>
  
  <entry>
    <title>Prettier Nedir?</title>
    <link href="https://wepod.github.io/blog/Prettier-Nedir/"/>
    <id>https://wepod.github.io/blog/Prettier-Nedir/</id>
    <published>2019-11-27T11:40:44.000Z</published>
    <updated>2019-12-17T08:47:00.888Z</updated>
    
    <content type="html"><![CDATA[<p>Prettier nedir? Standartın önemi nedir? Temiz kod yaklaşımı.</p><a id="more"></a><h3 id="Prettier-Nedir"><a href="#Prettier-Nedir" class="headerlink" title="Prettier Nedir?"></a>Prettier Nedir?</h3><p>Prettier, aşağıdakileri destekleyen bir kod formatlayıcısıdır:</p><ul><li>JavaScript, including ES2017</li><li>JSX</li><li>Angular</li><li>Vue</li><li>Flow</li><li>TypeScript</li><li>CSS, Less, and SCSS</li><li>HTML</li><li>JSON</li><li>GraphQL</li><li>Markdown, including GFM and MDX</li><li>YAML</li></ul><blockquote><p>Prettier, Tüm orijinal stilleri kaldırır ve gönderilen tüm kodların tutarlı bir stilde uyumlu olmasını sağlar. Yani kodunuzu alır, satır uzunluğunu hesaba katarak sıfırdan yazdırır.</p></blockquote><p>Örneğin aşağıdaki kod bloğunu inceleyelim:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo(arg1, arg2, arg3, arg4);</span><br></pre></td></tr></table></figure><p>Bu blok, tek bir satırda okunabilir. Bu yüzden stillendirmeye ihtiyacı yok. Ancak aşağıdaki kodda bu ihtiyacın doğduğunu görüyoruz:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo(reallyLongArg(), omgSoManyParameters(), IShouldRefactorThis(), isThereSeriouslyAnotherOne());</span><br></pre></td></tr></table></figure><p>Bu blok çok uzun olduğundan bunu ayırmamız gerekiyor. Prettier, sizin için bu şekilde yeniden yazıyor:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">foo(</span><br><span class="line">  reallyLongArg(),</span><br><span class="line">  omgSoManyParameters(),</span><br><span class="line">  IShouldRefactorThis(),</span><br><span class="line">  isThereSeriouslyAnotherOne()</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>Prettier, kod tabanınızın tamamında tutarlı bir kod stili (örn. AST’yi etkilemeyecek kod formatı) uygular.</p><h3 id="Standartin-Onemi"><a href="#Standartin-Onemi" class="headerlink" title="Standartın Önemi"></a>Standartın Önemi</h3><p>Standartın önemini bir örnek ile açıklayabilirim:</p><iframe style="width:100%;height: 630px;" height="630" scrolling="no" title="Standard-agnostic clock" src="https://codepen.io/siddhant-k-code/embed/OJJGNLJ?height=627&theme-id=light&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true">  See the Pen <a href="https://codepen.io/siddhant-k-code/pen/OJJGNLJ" target="_blank" rel="noopener">Standard-agnostic clock</a> by Siddhant Khare  (<a href="https://codepen.io/siddhant-k-code" target="_blank" rel="noopener">@siddhant-k-code</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</iframe><p>Gördüğünüz gibi, saat okumak gibi basit bir iş, standart olmadığında bir eziyete dönüşüyor. Kod için de aynı, başka birinin standartlara uymayan kodunu okuduğunuz zaman, buna alışmak zaman alıyor. Zaman ise, bildiğiniz gibi, projelerdeki en önemli kavram.</p><h3 id="Ozgurluk"><a href="#Ozgurluk" class="headerlink" title="Özgürlük"></a>Özgürlük</h3><p>Prettier, aslında istediğiniz şekilde kod yazmayı kolaylaştırıyor, çünkü daha sonra anında doğru bir şekilde formatlıyor. Böylece takımınızla birlikte, birleşik bir kod yazabiliyorsunuz.</p><p>Noktalı virgül yazmayı umursamıyor musunuz? Aşağıdakini yazın, Prettier sizin için zaten formatlıyor.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  var x = 5</span><br><span class="line">  var y = 6</span><br><span class="line">  var z = 7</span><br><span class="line">  return x + y + z</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Bir takımda çalışırken sürtünmeyi azaltmak çok önemli. Bu sorun, özellikle büyük takımlarda gerçekleşiyor. Tamamen sürtünmeden kaçınmak imkansız, ancak daha iyi çalışmayı kolaylaştırmak için Prettier gibi araçlardan faydalanabilirsiniz.</p><p>Kaynaklar: <a href="https://prettier.io/docs/en/index.html" target="_blank" rel="noopener">Prettier Docs</a> <a href="https://jlongster.com/A-Prettier-Formatter" target="_blank" rel="noopener">James Long</a> <a href="https://codepen.io/siddhant-k-code/pen/OJJGNLJ" target="_blank" rel="noopener">Siddhant Khare</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Prettier nedir? Standartın önemi nedir? Temiz kod yaklaşımı.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="atagulalan" scheme="https://wepod.github.io/tags/atagulalan/"/>
    
  </entry>
  
  <entry>
    <title>Öğrenme Teorileri</title>
    <link href="https://wepod.github.io/blog/Ogrenme-Teorileri/"/>
    <id>https://wepod.github.io/blog/Ogrenme-Teorileri/</id>
    <published>2019-11-27T10:06:44.000Z</published>
    <updated>2019-12-17T08:47:00.888Z</updated>
    
    <content type="html"><![CDATA[<p>Öğrenme teorileri nedir? Çocuğun daha hızlı ve iyi anlamasını nasıl sağlayabiliriz?</p><a id="more"></a><h3 id="Teknoloji-ile-Ogrenme"><a href="#Teknoloji-ile-Ogrenme" class="headerlink" title="Teknoloji ile Öğrenme"></a>Teknoloji ile Öğrenme</h3><p>Öğrenme, bireyin olgunlaşma düzeyine göre, çevresi ile etkileşimi sonucunda kişide yaşantı ürünü oluşan ve kalıcı olan davranış değişmesidir.</p><p>ABD’deki Texas Üniversitesinde Philips tarafından yapılan araştırma sonuçlarına göre insanlar; okuduklarının %10’unu, görüp işittiklerinin <strong>%50</strong>’sini, işittiklerinin <strong>%20</strong>’sini, söylediklerinin <strong>%70</strong>’ini, gördüklerinin <strong>%30</strong>’unu yapıp, söylediklerinin <strong><em>%90</em></strong>’ını hatırlamaktadırlar. Zaman faktörü sabit tutularak elde edilen bu oranlar, sınıf içinde çok ortamlı öğretme durumunun düzenlenmesi gerektiğini göstermektedir. Çoklu ortamlı öğretme durumunun gerçekleşmesi ise bilgisayar destekli eğitim ile mümkün olabilmektedir.</p><p>Teknoloji, bilimi kullanarak günlük hayatımızdaki işleri daha hızlı ve güvenli yapmak için kullanılan etmenleri ifade eder. Çamaşır ve bulaşık makineleri nasıl gündelik işleri kolaylaştırıyor ise, teknoloji ile öğrenim de öğrenmeyi kolaylaştıracak ve hızlandıracaktır. Buna örnek olarak akıllı tahtalar, projeksiyon cihazları, elektronik destek sistemleri verilebilir.</p><p>Teknoloji, öğrencinin bilgiye ulaşımını kolaylaştırmış ve <strong>eğitim kalitesini</strong> arttırmıştır.</p><p><img src="/blog/Ogrenme-Teorileri/tpib.png" alt="Teknolojik Pedagojik İçerik Bilgisi (TPİB)" title="Teknolojik Pedagojik İçerik Bilgisi (TPİB)"></p><p>Teknolojik Pedagojik İçerik Bilgisi (TPİB), içerik, pedagoji ve teknolojinin öğretim sürecindeki <strong>kesişim</strong> yeridir. TPİB’in amacı belli bir <em>konunun</em> (içerik), <em>teknolojiyi</em> kullanarak (teknoloji) <em>nasıl öğretileceği</em> (pedagoji) konusunda öğretmenlere yardımcı olmaktır. Çarpım tablosunun (içerik) teknoloji ile (teknoloji) nasıl daha iyi öğretileceği (pedagoji) TPİB’ ne örnektir.</p><h3 id="Ogrenme-Teorileri"><a href="#Ogrenme-Teorileri" class="headerlink" title="Öğrenme Teorileri"></a>Öğrenme Teorileri</h3><p>İnsanların nasıl öğrendiğine ve nasıl öğretileceğine dair çok fazla teori geliştirilmiştir. </p><blockquote><p>Teorilerin çoğaltılması bilime yararlıdır. Çünkü tek bir teori egemenliği eleştiri gücünü azaltır, tek bir teorinin egemenliği bireyin özgür gelişimini tehlikeye sokar. Düşünce tarihi, bilimin içine işleyerek tek tek her teorinin geliştirilmesinde kullanılmıştır.</p></blockquote><h4 id="Davranisci-Ogrenme"><a href="#Davranisci-Ogrenme" class="headerlink" title="Davranışçı Öğrenme"></a>Davranışçı Öğrenme</h4><p>Davranışçılar; öğrenmenin gerçekleşmesinin yani istenilen davranışları oluşturmanın, organizmaya dışarıdan gerekli uyarıcıların verilmesi ile gerçekleşeceğini, bunun da bir <strong>etki-tepki</strong> olduğunu açıklamışlardır. Asıl ilgi dışsal çevrenin (öğretim ortamlarının, materyallerinin ve stratejilerinin) planlanması üzerine yoğunlaşmaktadır.</p><p>Davranışçı öğretim teorisine göre şartlı tepki yoluyla öğrenme olduğu savunulur ve bu öğrenmede pekiştiricilerin (ödül veya ceza) nasıl kullanılacağı üzerinde durulur. Uygun öğrenme şartları hazırlandığında ve uyarıcı-tepki arasında sağlam bir bağ kurulduğunda <em>“Her öğrenci öğrenir”</em> ilkesi savunulur.</p><p>Davranışçı öğrenme teorisinin öğretim ilkelerinde yaparak öğrenme esastır ve pekiştiriciler önemli bir yer tutar. Kalıcılık ise tekrar ile sağlanır. İlk öğrenilenler, daha sonra öğrenilenleri etkiler; benzer bilgilerin öğrenimini kolaylaştırır. Eğer öğretilecek bilgi ve davranış çok fazla veya karmaşık ise, analiz yapıldıktan sonra bir <strong>öğretim planı</strong> yapılmalı ve <strong>kademeli</strong> olarak (ardışık sırayla) öğretilmelidir.</p><h4 id="Bilissel-Ogrenme"><a href="#Bilissel-Ogrenme" class="headerlink" title="Bilişsel Öğrenme"></a>Bilişsel Öğrenme</h4><p>Bilişsel öğrenme teorilerinde, öğrenme, kişinin davranımda bulunma kapasitesinin gelişmesidir.</p><p>Bellekteki bilginin değişmesi üzerine odaklaşan bilişselci psikologlar öğrenmenin doğrudan dışarıdan gözlenemeyen içsel bir zihinsel etkinlik olduğuna inanırlar. Öğrenme üzerine çalışan bilişselci psikologlar ise problem çözme, hatırlama gibi gözlenemeyen <em>zihinsel</em> etkinliklerle ilgilenirler.</p><p>Aynı probleme farklı cevaplar verilmesi bu ilkeyle açıklanabilir. Davranışları belirleyen nesnel gerçeklik değil, öznel gerçekliktir. Çevre ve durumlar aynı olsa dahi, problemin çözümü, bu problemin kişinin <strong><em>bilincinde nasıl anlaşıldığıyla</em></strong> ilgilidir.</p><p>Bilişselci yaklaşımda teknolojinin kullanılmasını şu şekilde açıklanabilir; <strong>Bilgisayar, birey için bir bilişsel rehber durumundadır</strong>. Var olan bilgileri bireye sunar ve bireyin gerçekleştirdiği işlemler doğrultusunda yönlendirme yapar. Bireyin öğrenmesi bu karşılıklı etkileşim sonucunda gerçekleşir. Bireyin hazır bulunuşluluk seviyesine göre ilerleme olduğu için bilgisayar programları bilişselci yaklaşıma uygun olarak düşünülebilir.</p><h4 id="Yapisalci-Ogrenme"><a href="#Yapisalci-Ogrenme" class="headerlink" title="Yapısalcı Öğrenme"></a>Yapısalcı Öğrenme</h4><p>Yapılandırmacı öğrenme toplumun değişen ihtiyaçlarını karşılamak için eğitimin yeniden yapılandırılmasının gereğini içeren görüşlerine dayandırılmaktadır. Yapılandırmacılığı yine Dewey gibi geleneksel eğitime karşı çıkan ve eğitimi hayata hazırlık olarak değil, eğitimin yaşamın kendisi için olduğunu savunan <em>J.J.Rousseau</em>’nun görüşüne de bağlantılı olduğunu savunulmaktadır.</p><p>Yapılandırmacı görüş, kişinin daha önceden benimsediği bilgileri, <strong>yeni problemler üzerinde uygulaması için yapılandırması</strong> prensibine dayalıdır. Yani bilgiler salt halde kullanılamaz, yeni problemlerin çözümü için yapılandırılarak kullanılır.</p><p>Yapılandırmacılığa ilişkin varsayımlarını şu şekilde belirlemiştir:</p><ul><li>Bilgi deneyimlerle yapılandırılır.</li><li>Öğrenme, dünyanın kişisel bir yorumudur.</li><li>Öğrenme, deneyimlere bağlı olarak geliştirilen aktif bir anlamlandırma sürecidir.</li><li>Kavramsal gelişim; anlamların paylaşılmasından, çoklu bakış açılarının paylaşılmasından ve içsel yansımalarımızın işbirlikçi öğrenmeye dönüşmesinden kaynaklanmaktadır.</li><li>Öğrenme gerçek durumlara göre belirlenmelidir; değerlendirme ayrı bir etkinlik olarak değil, hedeflerle bir bütün olarak yapılmalıdır.</li></ul><h5 id="Kaynaklar"><a href="#Kaynaklar" class="headerlink" title="Kaynaklar"></a>Kaynaklar</h5><ul><li>Bell‐Gredler, M.E., Learning and instruction: Theory into practice</li><li>Yalın, H.İ., Öğretim Teknolojileri ve Materyal Geliştirme</li><li>Yürütücü, A., Bilişim Toplumunda İlköğretim Sürecindeki Eğitim Teknolojileri</li><li>Durak, G., Algoritma Konusunda Geliştirilen “Programlama Mantığı Öğretici-P.M.Ö” Yazılımının Öğrenci Başarısına Etkisi</li><li>Duman, B., Öğrenme- Öğretme Kuramları ve Süreç Temelli Öğretim</li><li>Merrill, M.D., Construction and instructional design.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Öğrenme teorileri nedir? Çocuğun daha hızlı ve iyi anlamasını nasıl sağlayabiliriz?&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="atagulalan" scheme="https://wepod.github.io/tags/atagulalan/"/>
    
  </entry>
  
  <entry>
    <title>Styled Components</title>
    <link href="https://wepod.github.io/blog/Styled-Components/"/>
    <id>https://wepod.github.io/blog/Styled-Components/</id>
    <published>2019-11-25T23:27:22.000Z</published>
    <updated>2019-12-17T08:47:00.888Z</updated>
    
    <content type="html"><![CDATA[<p>Styled Components Nedir?, Styled Components Oluşturma, Biz Neden Tercih Ettik?</p><a id="more"></a><h4 id="Styled-Components-Nedir"><a href="#Styled-Components-Nedir" class="headerlink" title="Styled Components Nedir?"></a>Styled Components Nedir?</h4><p>Styled Components bizi uzun ve gittikçe karışan CSS kodlarından kurtaran, HTML elementlerini fonksiyonel stillendirmemizi sağlayan ve en önemlisi içerisinde JavaScript kodları kullanmamızı sağlayan bir teknolojidir. Geleneksel stil yazma metodunun dışına çıkarak, temasal ve işlevsel stil bileşenleri (components) oluşturmamızı sağlar.</p><h4 id="Styled-Components-Olusturma"><a href="#Styled-Components-Olusturma" class="headerlink" title="Styled Components Oluşturma"></a>Styled Components Oluşturma</h4><p>Bileşen oluşturmak çok basittir. Önce Styled Components’i yüklememiz gerekiyor. Aşağıdaki şekilde yüklüyoruz.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install styled-components@beta</span><br></pre></td></tr></table></figure><p>Ardından bir stilli bileşen oluşturmak aşağıdaki kod parçası kadar kolay.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import stil from &apos;styled-components&apos;;</span><br><span class="line"></span><br><span class="line">const Title = stil.h1`</span><br><span class="line">  color: red;</span><br><span class="line">`;</span><br></pre></td></tr></table></figure><p>Bu şekilde Title adında kırmızı bir h1 bileşeni oluşturmuş olduk.</p><p>JavaScript kodlarını aşağıdaki gibi kolaylıkla CSS içine ekleyebiliyoruz.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const Button = stil.button`</span><br><span class="line">  color: $&#123;props =&gt; props.theme.fg&#125;;</span><br><span class="line">  border: 2px solid $&#123;props =&gt; props.theme.fg&#125;;</span><br><span class="line">  background: $&#123;props =&gt; props.theme.bg&#125;;</span><br><span class="line"></span><br><span class="line">  font-size: 1em;</span><br><span class="line">  margin: 1em;</span><br><span class="line">  padding: 0.25em 1em;</span><br><span class="line">  border-radius: 3px;</span><br><span class="line">`;</span><br></pre></td></tr></table></figure><p>Bu şekilde Props’lara bağlı dinamik bir bileşen yapısını CSS içinde oluşturmuş olduk.</p><h4 id="Biz-Neden-Styled-Components-Kullanmayi-Tercih-Ettik"><a href="#Biz-Neden-Styled-Components-Kullanmayi-Tercih-Ettik" class="headerlink" title="Biz Neden Styled-Components Kullanmayı Tercih Ettik?"></a>Biz Neden Styled-Components Kullanmayı Tercih Ettik?</h4><p>Cevabı çok basit; kolaylık ve rahatlık. CSS içerisinde JavaScript kodu yazabilmemiz ve server-side rendering özelliğini desteklemesi nedeniyle, bu yöntemi projemizde kullanmayı tercih ediyoruz. Styled-Components, stylesheet rehydration ile eşzamanlı server-side rendering’i destekler. Aşağıdaki kıyaslama görseli de seçimimizin ne kadar doğru olduğunu kanıtlar niteliktedir.<br><img src="/blog/Styled-Components/styledcomponents.jpeg" alt="Styled Components Vs Others" title="Styled Components Kıyaslaması"></p><p>Kaynaklar : <a href="https://www.styled-components.com/" target="_blank" rel="noopener">styled-components</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Styled Components Nedir?, Styled Components Oluşturma, Biz Neden Tercih Ettik?&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="oguzturker8" scheme="https://wepod.github.io/tags/oguzturker8/"/>
    
  </entry>
  
  <entry>
    <title>POD | Ön Rapor</title>
    <link href="https://wepod.github.io/blog/Ikinci-Is-Paketi/"/>
    <id>https://wepod.github.io/blog/Ikinci-Is-Paketi/</id>
    <published>2019-11-25T22:34:26.000Z</published>
    <updated>2019-12-17T08:47:00.888Z</updated>
    
    <content type="html"><![CDATA[<p>POD Projesi, 2. İş Paketi, Ön Rapor</p><a id="more"></a><p>Düzgün görüntülenmiyorsa <a href="https://docs.google.com/document/d/e/2PACX-1vQuXSVGo5UgDetQEZEm9eG5Pm4yqGNA8whSHKVq7NvNKcXGk6heyJQd_MBGQ9u5_fY_abtKHf1sSquY/pub?embedded=true" target="_blank" rel="noopener">buraya tıklayın</a></p><iframe src="https://docs.google.com/document/d/e/2PACX-1vQuXSVGo5UgDetQEZEm9eG5Pm4yqGNA8whSHKVq7NvNKcXGk6heyJQd_MBGQ9u5_fY_abtKHf1sSquY/pub?embedded=true" style="overflow:hidden;height:9200px;width:100%;"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;POD Projesi, 2. İş Paketi, Ön Rapor&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="atagulalan" scheme="https://wepod.github.io/tags/atagulalan/"/>
    
      <category term="oguzturker8" scheme="https://wepod.github.io/tags/oguzturker8/"/>
    
      <category term="stunali" scheme="https://wepod.github.io/tags/stunali/"/>
    
  </entry>
  
  <entry>
    <title>POD | Tübitak 2209-A</title>
    <link href="https://wepod.github.io/blog/2209A-Tubitak/"/>
    <id>https://wepod.github.io/blog/2209A-Tubitak/</id>
    <published>2019-11-25T22:14:56.000Z</published>
    <updated>2019-12-17T08:47:00.888Z</updated>
    
    <content type="html"><![CDATA[<p>POD Projesi, 1. İş Paketi, Tübitak 2209-A</p><a id="more"></a><p>Düzgün görüntülenmiyorsa <a href="https://docs.google.com/document/d/e/2PACX-1vQLU0lVmXSCa2M0Nj-8iCnFXRWS9ArRRKQpNKZGBmisFOkN-1GfsGmC3-Hi6YGHUw/pub?embedded=true" target="_blank" rel="noopener">buraya tıklayın</a></p><iframe src="https://docs.google.com/document/d/e/2PACX-1vQLU0lVmXSCa2M0Nj-8iCnFXRWS9ArRRKQpNKZGBmisFOkN-1GfsGmC3-Hi6YGHUw/pub?embedded=true" frameborder="0" style="overflow:hidden;height:5600px;width:100%;"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;POD Projesi, 1. İş Paketi, Tübitak 2209-A&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="atagulalan" scheme="https://wepod.github.io/tags/atagulalan/"/>
    
      <category term="oguzturker8" scheme="https://wepod.github.io/tags/oguzturker8/"/>
    
      <category term="stunali" scheme="https://wepod.github.io/tags/stunali/"/>
    
  </entry>
  
  <entry>
    <title>Kullanacağımız Teknolojiler</title>
    <link href="https://wepod.github.io/blog/Kullanacagimiz-Teknolojiler/"/>
    <id>https://wepod.github.io/blog/Kullanacagimiz-Teknolojiler/</id>
    <published>2019-11-25T21:41:19.000Z</published>
    <updated>2019-12-17T08:47:00.888Z</updated>
    
    <content type="html"><![CDATA[<p>Teknoloji Seçimi, Ön Yüz, Sunucu Tarafı, Teknolojiler Hakkında</p><a id="more"></a><h4 id="Teknoloji-Secimi"><a href="#Teknoloji-Secimi" class="headerlink" title="Teknoloji Seçimi"></a>Teknoloji Seçimi</h4><p>Projemiz, bir web projesi olduğundan ön yüz tarafında kullanılabilecek teknolojiler sınırlı. Arka yüz tarafında ise sadece kullanıcı bilgileri tutulacağından, kompleks frameworkler yerine daha basit frameworkler kullanmayı planlıyoruz. Projemizin <strong>PWA</strong> olması gerektiğini düşünüyoruz. Projemizin tek bir dil üzerinden yazılması ile kodun, hangi yüzde çalışıldığına bakmadan, tüm proje üyeleri tarafından kolayca anlaşılacağını düşünüyoruz.</p><h4 id="On-Yuz-icin"><a href="#On-Yuz-icin" class="headerlink" title="Ön Yüz için"></a>Ön Yüz için</h4><ul><li><strong>HTML</strong> (Hyper Text Markup Language),</li><li><strong>CSS</strong> (Cascading Style Sheets),</li><li><strong>Vue.js</strong> (sunucu tarafında render etmek için <strong>Nuxt.js</strong>)</li></ul><h4 id="Sunucu-Tarafi-Icin"><a href="#Sunucu-Tarafi-Icin" class="headerlink" title="Sunucu Tarafı İçin"></a>Sunucu Tarafı İçin</h4><ul><li><a href="https://wepod.github.io/blog/Node-Js/"><strong>Node.js</strong></a>,</li><li><strong>MongoDB</strong></li></ul><h4 id="Kullanici-Deneyimi-Icin"><a href="#Kullanici-Deneyimi-Icin" class="headerlink" title="Kullanıcı Deneyimi İçin"></a>Kullanıcı Deneyimi İçin</h4><ul><li><a href="https://wepod.github.io/blog/Progressive-Web-App/"><strong>PWA</strong></a> (Progressive Web Apps), ,</li><li><a href="https://wepod.github.io/blog/Betik-Dili/"><strong>Betik Dili</strong></a>,</li><li><strong>Adobe Illustrator</strong>,<br>teknolojilerini kullanmaya karar verdik.</li></ul><h4 id="Kullanilacak-Teknolojiler-Hakkinda"><a href="#Kullanilacak-Teknolojiler-Hakkinda" class="headerlink" title="Kullanılacak Teknolojiler Hakkında"></a>Kullanılacak Teknolojiler Hakkında</h4><ul><li>Her tarayıcının okuyup anlayabildiği HTML standardı ile <strong>platform bağımsız</strong> bir uygulama geliştireceğiz. Böylelikle hangi tarayıcıdan veya hangi platformdan girdiğinize bakmadan, Chrome, Yandex Browser, Firefox, Opera,Safari gibi web tarayıcılarının okuyup anladığı bir uygulama tasarlayacağız.</li><li>CSS bir siteyi renklendirmeyi ve biçimlendirmeyi sağlar. HTML iskeletinin üzerine giydirilen bir kıyafet gibi düşünülebilir.</li><li>Vue.js kullanıcı arayüzleri ve tek sayfa uygulamalar inşa etmek için kullanılan <strong>MVC modeli</strong> açık kaynak Javascript framework’üdür. Bu çıktıyı sunucu tarafında çalıştırmak (render etmek) için Nuxt.js kullanacağız.</li><li>Ayrıca projemizi PWA yapacağız. Böylelikle projemiz her platformda (telefon, bilgisayar, tablet) kullanabilir olacak ve <strong>internet gerektirmeyecektir</strong>. Aynı bir uygulama gibi bilgisayarınıza indirebildiğiniz, ya da web üzerinden oynayabildiğiniz bir uygulama olacak.</li><li>Arka yüzde ise Node.js (Chrome v8 Javascript Engine) kullanarak <strong>server-side</strong> tarafında yine Javascript kodlarımızı çalıştıracağız. Böylece hem ön yüzde, hem de arka yüzde Javascript yazarak birden fazla dil karmaşıklığının önüne geçeceğiz.</li><li>Veritabanı olarak MongoDB kullanacağız. MongoDB, 2009 yılında geliştirilmiş açık kaynak kodlu bir <strong>NoSQL</strong> veritabanıdır.</li><li>Projeyi gerçekleştirirken kendi sözdizimi yapımızı oluşturacağız. Böylece kodu kopyalama, paylaşma gibi işlevler yapılmasının yanı sıra, satır satır yorumlayarak <strong>her aşamayı ekranda gösterebileceğiz</strong>.</li><li>Bölümleri, ekranları tasarlamak için Adobe Illustrator kullanıyoruz. Bu program, tasarladığımız bölümleri ve görselleri <strong>SVG</strong> formatında çıktı veriyor. Böylece hangi cihazda çalıştırıldığına bakmadan, görselleri yeniden boyutlandırdığımızda bulanık gözükmüyor ve görselleri eklerken sorun yaşamıyoruz.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Teknoloji Seçimi, Ön Yüz, Sunucu Tarafı, Teknolojiler Hakkında&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="oguzturker8" scheme="https://wepod.github.io/tags/oguzturker8/"/>
    
  </entry>
  
  <entry>
    <title>Betik Dili</title>
    <link href="https://wepod.github.io/blog/Betik-Dili/"/>
    <id>https://wepod.github.io/blog/Betik-Dili/</id>
    <published>2019-11-25T17:01:13.000Z</published>
    <updated>2019-12-17T08:47:00.888Z</updated>
    
    <content type="html"><![CDATA[<p>Betik Dili Nedir?, POD İçinde Betik Dili, Betik Dili Operasyon Kodları</p><a id="more"></a><h4 id="Betik-Dili-Nedir"><a href="#Betik-Dili-Nedir" class="headerlink" title="Betik Dili Nedir?"></a>Betik Dili Nedir?</h4><p>Betik Dili (Scripting/Script Language), <strong>betik yorumlamak</strong> için yazılmış özel çalışma-zamanı sistemlerinin (run-time environment) yorumlayabileceği programlama dilleridir. Diğer programlama dilleri ile yazılan kodlar makine koduna çevrilip çıkan program doğrudan çalıştırılırken betik kodları <strong>interpreter</strong> tarafından doğrudan okunur ve yorumlanarak işlemler interpreter’ın kendisi tarafından yapılır. Betik dillerinin en önemli farkı, derleme adımına ihtiyaç duymamasıdır. Bu diller, yorumlanarak çalışır.</p><p>Örneğin, normalde, bir C programının çalıştırmadan önce derlenmesi gerekirken JavaScript veya PHP gibi bir betik dili derlenmeden çalışabilir.</p><h4 id="POD-Icinde-Betik-Dili"><a href="#POD-Icinde-Betik-Dili" class="headerlink" title="POD İçinde Betik Dili"></a>POD İçinde Betik Dili</h4><p>Projeyi tasarlarken üzerinde durduğumuz en önemli şey, bu projenin, çocuklara programlama ve algoritma öğreten diğer hiçbir projeye benzememesini sağlamaktır. Bunun için diğer projelerdeki gibi iç içe geçen bloklar kullanmak yerine daha sade, problemi kısıtlı kaynaklarla çözmeye zorlayan bir betik dili geliştirmeye karar verdik. Projede kullanılacak olan betik dilinin ilk prototiplerini yapmış bulunmaktayız.</p><p>Aşağıdaki şekilde giriş olarak verilen her iki sayıyı karşılaştıran, eşitse çıkışa koyan bir program yazılmıştır. Bunun dışında sıfırları eleyen, her sayıyı sekizle çarpan, her iki sayıyı tersten yazan, sadece tek sayıları bulan programlar da yazmak mümkündür.</p><p><img src="/blog/Betik-Dili/betikdili.jpg" alt="Prototikte Bulunan Betik Dili" title="Prototikte Bulunan Betik Dili"></p><h4 id="Betik-Dili-Operasyon-Kodlari"><a href="#Betik-Dili-Operasyon-Kodlari" class="headerlink" title="Betik Dili Operasyon Kodları"></a>Betik Dili Operasyon Kodları</h4><p>Aşağıda, betik dilinden proje içinde kullanılan bazı <strong>operasyon kodu</strong> örnekleri verilmiştir:</p><p><strong>CME</strong> : Come. JMP veya JMZ’den dönüş için kullanılır.<br><strong>INP</strong> : Input. Girdi dizisinden bir eleman almak için kullanılır.<br><strong>OUT</strong> : Output. Çıktı dizisine eldeki elemanı vermek için kullanılır.<br><strong>CPY</strong> : Copy. Eldeki elemanı bellek kısmına kopyalamak için kullanılır.<br><strong>GET</strong> : Get. Bellekteki elemanı ele kopyalamak için kullanılır.<br><strong>SUB</strong> : Substract. Eldeki elemandan bellekteki elemanı çıkartmak için kullanılır.<br><strong>ADD</strong> : Add. Eldeki eleman ile bellekteki elemanı toplamak için kullanılır.<br><strong>JMP</strong> : Jump. Aynı etikete sahip CME satırına koşulsuz atlamak için kullanılır.<br><strong>JPZ</strong> : Jump If Zero. Aynı etikete sahip CME satırına eldeki eleman sıfır olmak koşuluyla atlamak için kullanılır.</p><p>Kaynaklar : <a href="https://tr.wikipedia.org/wiki/Betik_dili" target="_blank" rel="noopener">Wikipedia</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Betik Dili Nedir?, POD İçinde Betik Dili, Betik Dili Operasyon Kodları&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="oguzturker8" scheme="https://wepod.github.io/tags/oguzturker8/"/>
    
  </entry>
  
  <entry>
    <title>Node.Js</title>
    <link href="https://wepod.github.io/blog/Node-Js/"/>
    <id>https://wepod.github.io/blog/Node-Js/</id>
    <published>2019-11-24T11:30:00.000Z</published>
    <updated>2019-12-17T08:47:00.888Z</updated>
    
    <content type="html"><![CDATA[<p>Bu yazıda Node.js, npm ve node modülleri üzerinde duruldu.</p><a id="more"></a><p>Node.js JavaScript ekosisteminin en çok kullanılan frameworklerinden biridir.<br>Node.js’in gelmesi ile birlikte artık JavaScript yazarak backend geliştirme olanağına sahip olduk.<br>Bundan önce JavaScript kodlarını sadece tarayıcı tarafında çalıştırabiliyorduk.<br>Node.js “Chrome’un v8 JavaScript Engine” kullanarak server-side tarafında JavaScript kodlarımızı çalıştırır.<br>Bu engine JavaScript kodlarımızı alır ve makine koduna dönüştürür. </p><h2 id="Neden-Node-js"><a href="#Neden-Node-js" class="headerlink" title="Neden Node.js"></a>Neden Node.js</h2><p>Node.js olaya dayalı, asenkron fonksiyonlar kullanır ve bu onu hızlı ve verimli yapar.<br>Node.js dünyanın en büyük açık kaynak kodlu (npm) paketlerine sahiptir. Bu bize modülerlik sağlar.</p><h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><p>Npm bir paket yöneticisidir. Bu paket yöneticisini kullanarak problemlerinizi çözebilirsiniz. Açık kaynak yazılımdır.<br>Bu paket yöneticisi hızlı ve verimli kod yazmayı sağlar.</p><h2 id="Node-modulleri"><a href="#Node-modulleri" class="headerlink" title="Node modülleri"></a>Node modülleri</h2><p>Node modülleri, başka kodu etkilemeyen, yeniden kullanılabilir kod bloklarıdır.<br>Kendi modüllerinizi yazabilir ve çeşitli uygulamalarda kullanabilirsiniz. Node.js, daha fazla kurulum yapmadan kullanabileceğiniz bir dizi yerleşik modüle sahiptir.<br>Bir node modülü çıkartmak için yapmanız gereken tek şey <code>module.exports</code> kullanmaktır.<br>Bu kodu, farklı bir projede veye kod bloğunda <code>require</code> yardımıyla çalıştırabilirsiniz.<br>Bu sistem projede modülerlik sağlar, projenin maliyetini düşürür ve daha hızlı çalışmanıza olanak tanır.</p><p>Günümüzde Linkedin Node.js teknolojisine geçmiştir. Node.js’e geçişten sonra sunucu maaliyeti 1/10 düşmüştür.<br>Node.js kullanan bir başka firma da PayPal’dır. </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Bu yazıda Node.js, npm ve node modülleri üzerinde duruldu.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="stunali" scheme="https://wepod.github.io/tags/stunali/"/>
    
  </entry>
  
  <entry>
    <title>Progressive Web Apps</title>
    <link href="https://wepod.github.io/blog/Progressive-Web-App/"/>
    <id>https://wepod.github.io/blog/Progressive-Web-App/</id>
    <published>2019-10-08T23:03:13.000Z</published>
    <updated>2019-12-17T08:47:00.888Z</updated>
    
    <content type="html"><![CDATA[<p>Progressive Web Apps Nedir?, Nasıl Çalışır?, Özellikleri Nedir?</p><a id="more"></a><h4 id="Progressive-Web-Apss-PWA"><a href="#Progressive-Web-Apss-PWA" class="headerlink" title="Progressive Web Apss (PWA)"></a>Progressive Web Apss (PWA)</h4><p>Progressive Web App kısaca PWA, web sitelerinin görünümünü ve kullanıcı deneyimini, mobil uygulamalarla benzer seviyeye getirilen uygulamalara verilen isimdir. Bu yaklaşım ile tasarlanan web sitelerini mobil tarayıcıdan ziyaret ettiğinizde, sanki bir web sitesini değil bir mobil uygulamayı kullanıyormuş gibi bir deneyim yaşarsınız.</p><h4 id="PWA-Calisma-Mantigi"><a href="#PWA-Calisma-Mantigi" class="headerlink" title="PWA Çalışma Mantığı"></a>PWA Çalışma Mantığı</h4><p>PWA olarak tasarlanmış bir web sitesine mobil cihazlardaki güncel bir <strong>Chrome</strong> tarayıcı ile girdiğinizde, tarayıcı bu uygulamayı <strong>kısayol olarak ana ekranınıza eklemek ister misiniz</strong> diye soruyor. Eğer kabul ederseniz web sitesi artık telefonunuzun ekranının tamamını kaplıyor ve normal bir mobil uygulama gibi çalışmaya başlıyor. Burada çalışan yine bir web sayfası, ancak gerek tasarımsal gerekse kullanıcı deneyimi açısından doğru dizayn edilmiş bir PWA’da bunu farketmeniz çok zor oluyor.</p><p>PWA’nın önemli bileşeni <strong>Service Worker</strong> ise web içeriğinin mobil cihaza yüklenmesini sağlar. Böylece telefonunuz internete bağlı olmasa bile uygulamayı açtığınızda siz telefona aktarılan tüm içeriği ziyaret edebilirsiniz.</p><p><img src="http://devnot.com/wp-content/uploads/2017/05/progressive-web-apps-1.png" alt="Aliexpress PWA Kullanımı" title="Aliexpress PWA Kullanımı"></p><h4 id="PWA-Ozellikleri"><a href="#PWA-Ozellikleri" class="headerlink" title="PWA Özellikleri"></a>PWA Özellikleri</h4><ul><li>Service Worker ile yavaş internet hızına rağmen hızlıca yüklenme</li><li>Bir uygulama gibi telefonun ekranında ikon koyabilme</li><li>Full Screen sayfa gösterimi ve Splash Screen</li><li>Push Notification gönderme</li><li>Service Worker’in gelişimi ile offline mode’da çalıştığı gibi yavaş bağlantıda da sorunsuz çalışma</li><li>Kullanıcıyı Google Play Store’a yönlendirmeden tarayıcı üzerinden ana ekran ikonu ekleme</li><li>Uygulama navigasyonunu ve uygulama etkileşimini kullanabilme</li><li>Cep telefonunuza sadece kısayol ikonu eklediği için mobil uygulamaları yüklerken karşılaştığımız yetersiz hafıza sorunu ile karşılaşmama</li></ul><p>Kaynaklar : <a href="https://medium.com/@atamanonur/desktop-ve-mobil-web-in-geleceği-progressive-web-apps-379f3f4514a9" target="_blank" rel="noopener">atamanonur</a>, <a href="http://devnot.com/2017/progressive-web-apps-pwa-nedir/" target="_blank" rel="noopener">devnot</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Progressive Web Apps Nedir?, Nasıl Çalışır?, Özellikleri Nedir?&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="oguzturker8" scheme="https://wepod.github.io/tags/oguzturker8/"/>
    
  </entry>
  
  <entry>
    <title>POD Nedir?</title>
    <link href="https://wepod.github.io/blog/Pod-Nedir/"/>
    <id>https://wepod.github.io/blog/Pod-Nedir/</id>
    <published>2019-09-30T21:23:49.000Z</published>
    <updated>2019-12-17T08:47:00.888Z</updated>
    
    <content type="html"><![CDATA[<p>Biz kimiz, amacımız ne ve neden bu kadar önemli?</p><a id="more"></a><p>Kocaeli Üniversitesi Bilgisayar Mühendisliği son sınıf öğrencileri olarak yapacak olduğumuz projenin amaçlarını, projede kullanılacak araçları ve projenin geliştirimini olabildiğince detaylı bir şekilde bu blogda paylaşmayı düşünüyoruz.</p><p>Bu proje, 4. sınıf öğrencileri <a href="https://github.com/atagulalan" target="_blank" rel="noopener">Ata Gülalan</a>, <a href="https://github.com/oguzturker8" target="_blank" rel="noopener">Oğuzhan Türker</a> ve <a href="https://github.com/fxy0" target="_blank" rel="noopener">Serdar Tunalı</a>, Araştırma Problemleri ve Bitirme Projesi dersleri kapsamında <a href="http://akademikpersonel.kocaeli.edu.tr/pinar.onaydurdu/" target="_blank" rel="noopener">Yar. Doç. Dr. Pınar ONAY DURDU</a> gözetmenliğinde yürütülecektir.</p><p>Bu projede temel amacımız, çocuklara algoritma öğreten bir yapı geliştirmek.</p><p>Bu projeyi web tarayıcı üzerinde gerçekleyerek çok daha büyük bir kitleyi hedefliyoruz. Son zamanlarda iyice yaygınlaşan <strong>PWA (Progressive Web Apps)</strong> kullanarak, internet olmasa dahi cep telefonları ve tabletlerde çalışır hale getirmeyi planlıyoruz. Böylece hareket halinde, uçakta veya internetin olmadığı herhangi bir yerde dahi uygulamayı kullanılabilir sağlayarak çocuklarımızın eğitimine katkı sağlamayı amaçlıyoruz.</p><h4 id="Neden-cocuklara-algoritma-ve-kodlama-ogretmek-onemli"><a href="#Neden-cocuklara-algoritma-ve-kodlama-ogretmek-onemli" class="headerlink" title="Neden çocuklara algoritma ve kodlama öğretmek önemli?"></a>Neden çocuklara algoritma ve kodlama öğretmek önemli?</h4><p>Gelecek, daha fazla yazılımcı bekliyor. Gün geçtikçe yazılımcılara olan ihtiyaç artıyor ve <strong>yaratıcı düşünce</strong> gerektirmeyen çoğu meslek insanların elinden alınıp, bu işi daha iyi yapacak robotlara veriliyor.</p><p>Her ne kadar bu değişimden haz almasak da, bu değişim geleceğin bir parçası. Bu değişime çocuklarımızı hazırlamamız gerekiyor.</p><p>Bu proje ile çocuklara şu becerileri kazanmalarında yardımcı olacağız:</p><ul><li>Algoritmik düşünce</li><li>Mantıksal tasarım</li><li>Kritik karar alma</li><li>Yaratıcı düşünce</li><li>Süreklilik</li><li>Sabır</li><li>Kalıpların dışında düşünme</li><li>Farklı açılardan bakma</li></ul><p>Umarım bizim bu projeye başlarken hissettiğimiz gibi, siz de geleceğe umutla bakarsınız.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Biz kimiz, amacımız ne ve neden bu kadar önemli?&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="atagulalan" scheme="https://wepod.github.io/tags/atagulalan/"/>
    
  </entry>
  
</feed>
