<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Pod Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wepod.github.io/"/>
  <updated>2020-04-09T19:59:54.768Z</updated>
  <id>https://wepod.github.io/</id>
  
  <author>
    <name>Ata Gülalan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>İlk İlerleme Raporu</title>
    <link href="https://wepod.github.io/blog/Ilk-Ilerleme-Raporu/"/>
    <id>https://wepod.github.io/blog/Ilk-Ilerleme-Raporu/</id>
    <published>2020-04-09T20:41:13.000Z</published>
    <updated>2020-04-09T19:59:54.768Z</updated>
    
    <content type="html"><![CDATA[<p>İlk İlerleme Raporu</p><a id="more"></a><h4 id="Ilk-Ilerleme-Raporu"><a href="#Ilk-Ilerleme-Raporu" class="headerlink" title="İlk İlerleme Raporu"></a>İlk İlerleme Raporu</h4><p>İlk ilerleme raporunun detaylarını aşağıdan inceleyebilirisniz.</p><iframe src="https://docs.google.com/document/d/e/2PACX-1vQ6j-dPj-n0mZ1cZRvIdzNbwQt_gHTnAxmIMemNVKrti4ouDHpszUx2gyZGx7ppD0TrA6icFTwZej0c/pub?embedded=true" frameborder="0" style="overflow:hidden;height:2500px;width:100%;"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;İlk İlerleme Raporu&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="atagulalan" scheme="https://wepod.github.io/tags/atagulalan/"/>
    
      <category term="oguzturker8" scheme="https://wepod.github.io/tags/oguzturker8/"/>
    
      <category term="stunali" scheme="https://wepod.github.io/tags/stunali/"/>
    
  </entry>
  
  <entry>
    <title>Ana Ekran Tasarımı</title>
    <link href="https://wepod.github.io/blog/Authentication/"/>
    <id>https://wepod.github.io/blog/Authentication/</id>
    <published>2020-04-09T20:23:13.000Z</published>
    <updated>2020-04-09T19:59:54.764Z</updated>
    
    <content type="html"><![CDATA[<p>Frontend Authentication , Backend Authentication</p><a id="more"></a><h4 id="Frontend-Authentication"><a href="#Frontend-Authentication" class="headerlink" title="Frontend Authentication"></a>Frontend Authentication</h4><p>Kullanıcının authentication işlemleri için gerekli sayfaları oluşturduk. Hesap girişi, kayıt olma ve şifre sıfırlama ekranları oluşturduk. Bu ekranları ana sayfa ile birleştirdik. <strong>Modal’i</strong> elle çizilmiş gibi yaparak tasarımın temiz, ancak doğal gözükmesini amaçladık.</p><p><img src="/blog/Authentication/Authentication.jpg" alt="Authentication" title="Authentication"></p><h4 id="Backend-Authentication"><a href="#Backend-Authentication" class="headerlink" title="Backend Authentication"></a>Backend Authentication</h4><p>Bu hafta kullanıcının authentication işlemlerini gerçekleştirmek için gereken altyapı işlemlerini tanımladık. Öncelikle kullanıcının <strong>veritabanı modeli</strong> oluşturuldu. Daha sonra;</p><ul><li>login,</li><li>logout,</li><li>register,</li><li>resetPassword</li></ul><p><strong>router</strong> tanımları yapıldı.</p><p>Router tanımları yapıldıktan sonra <strong>controller</strong> tanımları yapıldı. Controller tanımlarında her bir işlem için ayrı fonksiyonlar içinde gerekli tanımlamalar yapıldı.</p><blockquote><p>Kullanıcı authentication işlemlerini yönetmek için JWT standardı kullanıldı.</p></blockquote><p>Kullanıcı giriş yaptıktan sonra üretilen <strong>token</strong>i kontrol edip <strong>API</strong>’lere erişebilmesi için gerekli olan <strong>middleware</strong> yapısı oluşturuldu.</p><ul><li>Kullanıcının güvenliği için girdiği şifreyi <strong>hash</strong>leme ve <strong>salt</strong> işlemlerini yapacak kütüphane projeye entegre edildi.</li><li>Kullanıcının şifresini unutması durumunda şifresini değiştirmesi için e-posta ile şifre yenileme mekanizması geliştirildi.</li><li>Şifre yenileme ekranında API işlemlerini yönetmek için token yapısı kullanıldı.</li><li>Oyunda oluşabilecek hataları yönetmek için merkezi bir hata mekanizması oluşturuldu.</li><li>Veritabanını bulut ortamında kullanmak için gerekli ayarlar yapıldı.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Frontend Authentication , Backend Authentication&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="atagulalan" scheme="https://wepod.github.io/tags/atagulalan/"/>
    
      <category term="oguzturker8" scheme="https://wepod.github.io/tags/oguzturker8/"/>
    
      <category term="stunali" scheme="https://wepod.github.io/tags/stunali/"/>
    
  </entry>
  
  <entry>
    <title>Ana Ekran Tasarımı</title>
    <link href="https://wepod.github.io/blog/Ana-Ekran-Tasarimi/"/>
    <id>https://wepod.github.io/blog/Ana-Ekran-Tasarimi/</id>
    <published>2020-04-09T20:23:13.000Z</published>
    <updated>2020-04-09T19:59:54.764Z</updated>
    
    <content type="html"><![CDATA[<p>Ana Ekran Tasarımı</p><a id="more"></a><h4 id="Ana-Ekran-Tasarimi"><a href="#Ana-Ekran-Tasarimi" class="headerlink" title="Ana Ekran Tasarımı"></a>Ana Ekran Tasarımı</h4><p>Projenin ana ekran tasarımında kaydırdıkça gözüken 4 bölüm bulunmaktadır. Bu bölümler ekran kaydırdıkça perspektifi değiştirerek sanki ekran üç boyutluymuş gibi gözüken erkranlardır.</p><blockquote><p>Bunu yapmamızdaki amaç, çocukların sayfaya olan ilgisini çekmek ve daha sonrasında ise bu ilgiyi yöneterek eğlenceli bir şekilde bilgi edinmelerini sağlamaktır.</p></blockquote><p>Ana ekranda kullanılan ilk “POD”, oyuna başlandığında ilk ekilecek olan <strong>bitkiyi</strong> ifade eder. Resimlerden de gördüğünüz üzere, ekranda bir çok hareketli nesne bulunmaktadır. Örneğin paranın dönüşü, robotun uçuşu, bulutların süzülüşü ve kutuların ilerleyişi gibi. Bu animasyonlar, kullanıcıyı sıkmadan bilgiyi aktarmak ve sayfada geçirilen süreyi arttırmak için tasarlanan küçük bileşenlerdir.</p><p><img src="/blog/Ana-Ekran-Tasarimi/anaEkranTasarimi.jpg" alt="Ana Ekran Tasarımı" title="Ana Ekran Tasarımı"></p><h4 id="Site-Adresi"><a href="#Site-Adresi" class="headerlink" title="Site Adresi"></a><a href="https://pod.xava.me/" target="_blank" rel="noopener">Site Adresi</a></h4><blockquote><p>Not: Mobil versiyon sitede şu anlık çalışmamaktadır.</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Ana Ekran Tasarımı&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="atagulalan" scheme="https://wepod.github.io/tags/atagulalan/"/>
    
      <category term="oguzturker8" scheme="https://wepod.github.io/tags/oguzturker8/"/>
    
      <category term="stunali" scheme="https://wepod.github.io/tags/stunali/"/>
    
  </entry>
  
  <entry>
    <title>Kasu</title>
    <link href="https://wepod.github.io/blog/Kasu/"/>
    <id>https://wepod.github.io/blog/Kasu/</id>
    <published>2020-04-09T20:15:13.000Z</published>
    <updated>2020-04-09T19:59:54.768Z</updated>
    
    <content type="html"><![CDATA[<p>Kasu, Kasu Tasarım, Kasu Animasyon</p><a id="more"></a><h4 id="Kasu-Tasarim"><a href="#Kasu-Tasarim" class="headerlink" title="Kasu Tasarım"></a>Kasu Tasarım</h4><blockquote><p>Bu hafta oyunun ana karakteri olan <strong>Kasu</strong> için bir component tanımladık.</p></blockquote><p>Bu komponentin içerisine dinamik olarak <strong>prop</strong> alabilen alt komponentler tanımladık. Böylece üst komponentte bir prop değişimini alt komponente atarak <strong>state management</strong>’i kolaylaştırdık.</p><blockquote><p>Problem, her bir komponentin üst üste render edilmesiydi.</p></blockquote><p>Örneğin Kasu’nun gözlüğünün, Kasu’nun sadece kafasını etkilemesi ve kafası hareket ettiğinde, gözlüğün de kafa ile beraber hareket etmesi gerekiyordu. Ancak gözlerin hareketi, gözlüğün hareketini etkilememeliydi. Ayrıca gözlük, gözlerin her zaman üstüne olmalıydı. Son olarak, gözleri tamamen kapayan gözlüklerin, gözleri gizlemesi gerekiyordu. Son olarak, gözlüğün kafanın arkasında değil, önünde render edilmesi gerekiyordu. Tüm bu problemleri ana komponentte düzenlememiz oldukça kafa karıştırıcı olabilirdi. Bu yüzden karakter bölümlendirmeyi buna göre belirledik.</p><p>İşin sonunda elimizde tamamen kişiselleştirebildiğimiz, küçük bölümlere bölünmüş bir karakter vardı. Rengini ve kullandığı eşyaları değiştiren bir ekran tasarlayacağız. Böylece kullanıcı, mağazadan aldığı eşyaları kuşanabilecek.</p><p><img src="/blog/Kasu/kasu2.jpg" alt="Kasu" title="Kasu"></p><h4 id="Kasu-Tasarim-1"><a href="#Kasu-Tasarim-1" class="headerlink" title="Kasu Tasarım"></a>Kasu Tasarım</h4><p>Aynı zamanda bu hafta, Kasu’nun CSS animasyonunu gerçekleştirdik. Bunu yaparken <strong>Chrome Dev Tools</strong>’un sağlamış olduğu <strong>Animations</strong> kısmı çok büyük yarar sağladı. Animasyonların zamanını ayarlamak ve Kasu’nun nefes alıp veriyormuş gibi salınmasını sağlamak, Kasu’ya canlılık kattı. Aynı zamanda, parçaların aynı animasyon class’ını kullanması, koddaki tekrarlığı azalttı.</p><p><img src="/blog/Kasu/kasu3.jpg" alt="Kasu’ya Hayat Katan Küçük Kod Parçacığı" title="Kasu’ya Hayat Katan Küçük Kod Parçacığı"></p><blockquote><p>Vee Kasu hareket ediyor :)</p></blockquote><p><img src="/blog/Kasu/kasu3.gif" alt="Kasu Hareket Ediyor" title="Kasu Hareket Ediyor"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kasu, Kasu Tasarım, Kasu Animasyon&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="atagulalan" scheme="https://wepod.github.io/tags/atagulalan/"/>
    
      <category term="oguzturker8" scheme="https://wepod.github.io/tags/oguzturker8/"/>
    
      <category term="stunali" scheme="https://wepod.github.io/tags/stunali/"/>
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="https://wepod.github.io/blog/Docker/"/>
    <id>https://wepod.github.io/blog/Docker/</id>
    <published>2020-01-18T19:03:22.000Z</published>
    <updated>2020-04-09T19:59:54.764Z</updated>
    
    <content type="html"><![CDATA[<p>Docker Nedir?, Klasik Sanal Makine vs Docker</p><a id="more"></a><h4 id="Docker-Nedir"><a href="#Docker-Nedir" class="headerlink" title="Docker Nedir"></a>Docker Nedir</h4><p>Docker 2013 yılında DotCloud şirketi tarafından çıkarılmıştır. Açık kaynak kodlu bir projedir. Docker, konteyner teknolojisi kullanarak uygulama oluşturma, dağıtma ve çalıştırma işlemlerini kolaylaştırmak için tasarlanmış bir araçtır. Geliştiriciler ve DevOps mühendisleri tarafından kullanılabilir. Konteyner teknolojisi yeni gelişmiş bir teknoloji olmayıp 2008`de ortaya çıkmıştır. LXC yapısı Linux’a eklenmiştir. Docker bu teknolojiye dayanır. Docker LXC ile yapılan işlemleri daha kolay, hızlı bir şekilde yapmamızı sağlar. Oracle VM VirtualBox, VMWare gibi sanallaştırma teknolojilerinden farkı akıllı kaynak yönetimi, daha kolay yönetilebilir, daha güvenli bir teknoloji sağlamasıdır. Bulut sistemleri ile uyumlu bir şekilde çalışılabilir ve yönetilebilir. İzole edilmiş yapıları sayesinde güvenlik bakımından da diğer teknolojilere göre avantajları vardır.</p><p><img src="/blog/Docker/docker-yapisi.png" alt="Docker Yapısı"></p><h4 id="Klasik-Sanal-Makine-vs-Docker"><a href="#Klasik-Sanal-Makine-vs-Docker" class="headerlink" title="Klasik Sanal Makine vs Docker"></a>Klasik Sanal Makine vs Docker</h4><p>VM’ler her bir çalışan örneği için full bir işletim sistemine sahiptir. Docker ise hem full işletim sistemi yerine boyut olarak küçültülmüş imajları kullanır hem de konak işletim sistemi kütüphanelerini paylaşımlı olarak kullanır. Fakat bu durum, Docker’i sistem kaynak tüketim dostu yaparken, izolasyon seviyesini ise düşürmektedir. Bunlarla birlikte aşağıdaki karşılaştırmaları yapabiliriz.</p><p><img src="/blog/Docker/sanal-makine-vs-docker.png" alt="Sanal  Makine vs Docker"></p><p>Docker Hypervisor ve tam yüklü bir işletim sistemi kullanmadığından maliyet kazancı çok büyüktür. Bir diğeri ise versiyonlamaya yatkınlığı. Docker’ın en vurucu özelliklerinden biride versiyonlanabilme özelliği. Docker, kullandığı işletim sistemi imajlarının farklı hallerini kayıt altında tutmamıza olanak sağlar.</p><p>Kaynaklar : <a href="https://www.mediaclick.com.tr/blog/docker-nedir-docker-ne-ise-yarar" target="_blank" rel="noopener">umutakkaya</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker Nedir?, Klasik Sanal Makine vs Docker&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="stunali" scheme="https://wepod.github.io/tags/stunali/"/>
    
  </entry>
  
  <entry>
    <title>NuxtJS</title>
    <link href="https://wepod.github.io/blog/Nuxt-JS/"/>
    <id>https://wepod.github.io/blog/Nuxt-JS/</id>
    <published>2019-12-17T15:21:33.000Z</published>
    <updated>2020-04-09T19:59:54.772Z</updated>
    
    <content type="html"><![CDATA[<p>NuxtJS Nedir?, Nasıl Çalışır?</p><a id="more"></a><h2 id="NuxtJS-Nedir"><a href="#NuxtJS-Nedir" class="headerlink" title="NuxtJS Nedir ?"></a>NuxtJS Nedir ?</h2><blockquote><p>NuxtJS VueJS, BabelJS, Webpack, NodeJS tabanlı web uygulamaları geliştirmek için kullanılan progressive bir frameworktür.</p></blockquote><p>NuxtJS , VueJS geliştiricileri için kolay ve hızlı web uygulamaları geliştirmek için altyapı oluşturmayı hedefler. <strong>Universal Vue Application</strong> (Sunucu Taraflı Rendering) üretmemize imkan tanır. Dosya ve klasör yapısını kullanarak konfigürasyon yapar.</p><p>VueJS çok performanslı bir frameworktür. NuxtJS , kullanıcı ile sunucu aransındaki <strong>Asynchronous Data</strong>, <strong>Middleware</strong>, <strong>Layouts</strong> vb. gibi geliştirmelerinizde, size yardımcı olan bir çok özelliği barındırır. NuxtJS , VueJS uygulamalarımızı daha <strong>kolay</strong> ve <strong>esnek</strong> inşa etmemizi sağlar.</p><h2 id="Server-Side-Rendering-Nedir"><a href="#Server-Side-Rendering-Nedir" class="headerlink" title="Server Side Rendering Nedir ?"></a>Server Side Rendering Nedir ?</h2><p>VueJS , istemci tabanlı rendering yapan bir Javascript frameworküdür. İstemci tabanlı rendering olayının avantajlı yanları olduğu gibi dezavantajlı yanları da vardır.<br><strong>SEO</strong> (Arama Motoru Optimizasyonu) ilk akla gelen avantajlarından biridir. NuxtJS sunucu taraflı rendering yaparak hem SEO açısından hem de arayüzümüzün daha hızlı açılması açısından bize avantaj sağlar.</p><h2 id="Calisma-Yapisi"><a href="#Calisma-Yapisi" class="headerlink" title="Çalışma Yapısı"></a>Çalışma Yapısı</h2><p>Aşağıdaki resimde bir kullanıcı uygulamamızda gezerken NuxtJS`in çalışma yapısını anlatılıyor.</p><p><img src="/blog/Nuxt-JS/NuxtJS.png" alt="NuxtJS Çalışma Yapısı" title="NuxtJS Çalışma Yapısı"></p><h2 id="Nuxt-Js-ile-gelistirebilecegimiz-Uygulamalar"><a href="#Nuxt-Js-ile-gelistirebilecegimiz-Uygulamalar" class="headerlink" title="Nuxt Js ile geliştirebileceğimiz Uygulamalar"></a>Nuxt Js ile geliştirebileceğimiz Uygulamalar</h2><ul><li><strong>Universal App :</strong> En basit haliyle, <strong>client</strong> tarafında yazdığımız kodun, <strong>sunucu</strong> tarafında işlenerek sunulması diyebiliriz.</li><li><strong>Single Page App :</strong> <strong>Single Page Application</strong> yönlendirme işleminin sunucu tarafından yapılmayıp Javascript ile <strong>istemci</strong> tarafında yapılmasıdır.</li><li><strong>Static App (Pre-render View) :</strong> Uygulamızı oluştururken yönlendiricilerimizin her biri için HTML oluşturur ve dosyada saklar.</li></ul><h2 id="Ozellikleri"><a href="#Ozellikleri" class="headerlink" title="Özellikleri"></a>Özellikleri</h2><p>-Sunucu taraflı rendering<br>-Güçlü routing sistemi<br>-Statik VueJS dosyası<br>-Kod ayırma sistemi</p><h4 id="Nasil-Calisir"><a href="#Nasil-Calisir" class="headerlink" title="Nasıl Çalışır?"></a>Nasıl Çalışır?</h4><p>NuxtJS aşağıdaki paketleri içerir;</p><p>-Vue 2<br>-Vue Router<br>-Vuex<br>-Vue Server Renderer<br>-Vue Meta</p><p>Kaynaklar : <a href="https://nuxtjs.org/guide" target="_blank" rel="noopener">NuxtJS</a>, <a href="https://oguzhan.in/nuxt-js-universal-vue-js-applications/" target="_blank" rel="noopener">oguzhanaslan</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;NuxtJS Nedir?, Nasıl Çalışır?&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="stunali" scheme="https://wepod.github.io/tags/stunali/"/>
    
  </entry>
  
  <entry>
    <title>POD | Prototip -1</title>
    <link href="https://wepod.github.io/blog/Prototip-1/"/>
    <id>https://wepod.github.io/blog/Prototip-1/</id>
    <published>2019-12-17T10:21:33.000Z</published>
    <updated>2020-04-09T19:59:54.772Z</updated>
    
    <content type="html"><![CDATA[<p>Prototip -1</p><a id="more"></a><h4 id="Pod-Prototip-1"><a href="#Pod-Prototip-1" class="headerlink" title="Pod | Prototip -1"></a>Pod | Prototip -1</h4><p>Prototipimizi <strong>Figma</strong> üzerinden yaptığımızı daha önceden söylemiştik.</p><blockquote><p>Figma’nın ne olduğunu ve nasıl çalıştığını merak ediyorsanız, <a href="https://wepod.github.io/blog/Figma">buradan</a> <strong>Figma</strong> adlı başlığımıza ulaşabilirsiniz.</p></blockquote><p>Prototipin başlangıcında oluşturacağımız sayfaları uygulama ve kullanıcı açısından grupladık. Daha sonra bunları açarak, aşağıdaki ekran sayfalarını oluşturduk;</p><ul><li>Yükleme Ekranı</li><li>Başlangıç Ekranı</li><li>Harita Ekranı</li><li>Bölümler Ekranı</li><li>Bölüm Ekranı</li><li>Editör Ekranı</li><li>Bitiş Ekranı</li><li>Giriş Yap Ekranı</li><li>Kayıt Ol Ekranı</li><li>Destek Ekranı</li><li>Nasıl Oynanır? Ekranı</li><li>Amacımız Ekranı</li></ul><h4 id="Yukleme-Ekrani"><a href="#Yukleme-Ekrani" class="headerlink" title="Yükleme Ekranı"></a>Yükleme Ekranı</h4><p>Yükleme ekranı oyunun açıldığından başlamaya hazır olduğu bölümü kapsamaktadır. Prototipte bu bölüm için dört ekran bulunmaktadır. Yavaş geçiş ile <strong>yüklenme efekti</strong> izlenimi verilmiştir.<br><img src="/blog/Prototip-1/yukleme-ekrani.png" alt="Yükleme Ekranı" title="Yükleme Ekranı"></p><h4 id="Baslangic-Ekrani"><a href="#Baslangic-Ekrani" class="headerlink" title="Başlangıç Ekranı"></a>Başlangıç Ekranı</h4><p>Başlangıç ekranında kullanıcı birçok işlem yapabilir. Buradaki metinlerle <strong>beş</strong> farklı ekrana geçiş yapabilir. Kullanıcı;</p><ul><li>Başla butonu ile oyuna başlayabilir,</li><li>Nasıl oynanır butonu ile oyunun nasıl oynandığını anlatan ekrana erişebilir,</li><li>Hesabım var butonu ile hesabına giriş yapabilir,</li><li>Destek butonundan destek sayfasına erişebilir,</li><li>Ya da amacımız butonu ile uygulamanın neden yapıldığını anlatan amacımız sayfasını görüntüleyebilir.</li></ul><p><img src="/blog/Prototip-1/baslangic-ekrani.png" alt="Başlangıç Ekranı" title="Başlangıç Ekranı"></p><h4 id="Harita-Ekrani"><a href="#Harita-Ekrani" class="headerlink" title="Harita Ekranı"></a>Harita Ekranı</h4><p>Oyunun bölümlerinin grupça bulunduğu ekrandır.</p><blockquote><p>Oyun bölümlerini ağacın yaprak ve dallarına benzetirsek, aynı özellikteki bölümlerin bulunduğu grup bir ağaç, ağaçların bulunduğu büyük gruba da orman benzetmesi yapmış oluruz. Bu şekilde çocuklara <strong>pozitif</strong> bir mesaj da vermeyi hedefledik.</p></blockquote><p>Bu ekranda üç çeşit olmak üzere toplam altı ormanımız bulunuyor. Bunlar;</p><ul><li>Belgrad</li><li>Redwood</li><li>Monteverde</li><li>Jiuzhaigou</li><li>Great Bear</li><li>Crooked</li></ul><p><img src="/blog/Prototip-1/harita-ekrani.png" alt="Harita Ekranı" title="Harita Ekranı"></p><h4 id="Bolumler-Ekrani"><a href="#Bolumler-Ekrani" class="headerlink" title="Bölümler Ekranı"></a>Bölümler Ekranı</h4><p>Bölümlerin bir arada bulunduğu, <strong>ağaç</strong> benzetmesini yaptığımız sayfa bu ekrandadır. İçinde bir bölüm bulunsa da şu an mevcut <strong>üç farklı ağaç tipi</strong>miz vardır.</p><p><img src="/blog/Prototip-1/bolumler-ekrani.png" alt="Bölümler Ekranı" title="Bölümler Ekranı"></p><h4 id="Bolum-Editor-Bitis-Ekranlari"><a href="#Bolum-Editor-Bitis-Ekranlari" class="headerlink" title="Bölüm - Editör - Bitiş Ekranları"></a>Bölüm - Editör - Bitiş Ekranları</h4><blockquote><p>Bu ekranlar birbiriyle etkileşimli olduğundan tek başlık altında anlatmak istiyoruz.</p></blockquote><p>Kullanıcının oyunu oynadığı bölümdür. Ağaçtan seçtiği yaprak ile ilgili bölümü açar. Şu an mevcut bir oyunumuz bulunuyor.</p><p>Bölümümüzde kullanıcıdan verilen bir dizi kutuların karşı tarafa yani çıkış bölümüne sırayla iletilmesi isteniyor. Kullanıcı bölümün alt kısmında bulunan ok ile <strong>editör sayfası</strong>nı açıp ilgili <strong>mantıksal sistemi</strong> kurması gerekiyor. Kullanıcı algoritmayı kurduktan sonra küçük arkadaşımız kutuları sırasıyla karşı tarafa iletmeye başlıyor.</p><p>Kullanıcı bölümü bitirdiğinde karşısına bitiş ekranı geliyor. Burada performansı ve kazandığı puan gibi bilgiler kullanıcıya gösteriliyor.<br>Kullanıcı devam et diyerek sonraki bölüme geçiş yapabilir.</p><p><img src="/blog/Prototip-1/multiple-ekran.png" alt="Bölüm - Editör - Bitiş Ekranları" title="Bölüm - Editör - Bitiş Ekranları"></p><h4 id="Giris-Yap-Kayit-Ol-Ekranlari"><a href="#Giris-Yap-Kayit-Ol-Ekranlari" class="headerlink" title="Giriş Yap - Kayıt Ol Ekranları"></a>Giriş Yap - Kayıt Ol Ekranları</h4><p>Kullanıcı başlangıçta hesabım var butonu ile giriş yapma ekranına ulaşabileceğini söylemiştik. Bu ekranda kullanıcı;</p><ul><li>Oyuna kayıt olduğu e-posta ve şifresi ile hesabına giriş yapabilir,</li><li>Cihazın hesabını tanıması için beni hatırla butonuna tıklayabilir,</li><li>Şifremi unuttum butonu ile şifresini kurtarabilir,</li><li>Veya kayıt ol butonu ile oyuna kayıt olabilir.</li></ul><h4 id="Nasil-Oynanir-Amacimiz-Ekranlari"><a href="#Nasil-Oynanir-Amacimiz-Ekranlari" class="headerlink" title="Nasıl Oynanır? - Amacımız Ekranları"></a>Nasıl Oynanır? - Amacımız Ekranları</h4><p>Kullanıcı bu iki ekrana da başlangıç ekranından ilgili butonlara tıklayarak ulaşabilmektedir.</p><p>Nasıl oynanır ekranında, kullanıcıya onunun nasıl oynanıldığı, oyunun fiziksel ve mantıksal mekaniği anlatılmaktadır.</p><p>Amacımız ekranında ise bizim uygulamayı neden yaptığımız, amacımızın ve hedeflerimizin ne olduğu ile ilgili metinler bulunmaktadır.</p><p><img src="/blog/Prototip-1/multiple-ekran2.png" alt="Bölüm - Editör - Bitiş Ekranları" title="Bölüm - Editör - Bitiş Ekranları"></p><h4 id="Figma-Onizleme"><a href="#Figma-Onizleme" class="headerlink" title="Figma Önizleme"></a>Figma Önizleme</h4><p>Buradan protipi inceleyebilir ve devamında yapacağımız değişiklikleri ve güncellemeleri takip edebilirsiniz.</p><iframe src="https://www.figma.com/embed?embed_host=share&url=https%3A%2F%2Fwww.figma.com%2Fproto%2F1BO43LpuV9KIt6UcbDx6y2%2FPOD-Prototype%3Fnode-id%3D12%253A167%26scaling%3Dscale-down" frameborder="0" style="overflow:hidden;height:800px;width:100%;"></iframe><p>Düzgün görüntülenmiyorsa <a href="https://www.figma.com/proto/1BO43LpuV9KIt6UcbDx6y2/POD-Prototype?node-id=3%3A60&scaling=scale-down" target="_blank" rel="noopener">buraya tıklayın</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Prototip -1&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="atagulalan" scheme="https://wepod.github.io/tags/atagulalan/"/>
    
      <category term="oguzturker8" scheme="https://wepod.github.io/tags/oguzturker8/"/>
    
      <category term="stunali" scheme="https://wepod.github.io/tags/stunali/"/>
    
  </entry>
  
  <entry>
    <title>Figma</title>
    <link href="https://wepod.github.io/blog/Figma/"/>
    <id>https://wepod.github.io/blog/Figma/</id>
    <published>2019-12-15T15:21:33.000Z</published>
    <updated>2020-04-09T19:59:54.764Z</updated>
    
    <content type="html"><![CDATA[<p>Figma Nedir?, Figma’nın Özellikleri, Başlarken</p><a id="more"></a><h2 id="Figma-Nedir"><a href="#Figma-Nedir" class="headerlink" title="Figma Nedir ?"></a>Figma Nedir ?</h2><blockquote><p>Figma, Linux, Mac OS ve Windows’ta çalışabilen bir bulut tabanlı tasarım aracıdır. Platform, kullanıcılarının tasarım oluşturmasını, prototip üretmesini ve tek bir araç içinde geri bildirim almasını sağlar.</p></blockquote><h2 id="Figma’nin-Ozellikleri"><a href="#Figma’nin-Ozellikleri" class="headerlink" title="Figma’nın Özellikleri"></a>Figma’nın Özellikleri</h2><ul><li><strong>Web tabanlıdır.</strong> Figma tarayıcınızda çalışır ve bunları projeleriniz üzerinde bilgisayarınıza ayrı dosyalar olarak kaydetmenize gerek kalmadan çalışabilirsiniz. Tüm düzenlemeler otomatik olarak bulutunuza kaydedilir. Ancak unutmayın, tüm değişiklikleri kaydetmek için aktif bir internet bağlantısına ihtiyacınız olduğunu unutmayın.</li><li><strong>Takım çalışmasına izin verir.</strong> Figma’da, fiyatlandırma planınıza bağlı olarak bir takımı ikiden sınırsız sayıda editöre şekillendirebilirsiniz. Tek bir projede kaç ekip üyesinin çalıştığını ve hangi değişiklikleri yaptıklarını her zaman görebileceksiniz.</li><li><strong>Yalnız tasarımcılar için ücretsiz.</strong> Tüm özellikler deneme süresi olmadan kullanmak tamamen ücretsizdir.</li><li><strong>Prototip.</strong> Figma, istediğiniz kadar ekran oluşturarak bir web sitesinin veya uygulamanın tıklanabilir bir versiyonunu oluşturmanıza olanak sağlar. Bu şekilde, sekmeler arasında geçiş yapmak zorunda kalmadan herhangi bir özelliği – düğme işlevi, öğelerin geçişi, kalıcı pencere animasyonu – test edebilir, düzenleyebilir veya ayarlayabilirsiniz. Gerçek bir ortamda nasıl görüneceğini simüle etmek için tasarımınız için bağlantılar ve sıcak noktalar oluşturabileceksiniz.</li><li><strong>Bileşenler.</strong> Bunlar, projelerinizde yeniden kullanılabilecek UI öğeleridir. Bu özellik onları çevirerek simetri bileşenleri oluşturmanıza veya bileşenleri döşeyerek desenleri tekrarlamanıza olanak tanır.</li><li><strong>Vektör Ağları</strong> Bu Figma özelliği, artık sadece iki noktadan gelen iki çizgiyle sınırlı olmadığınız için karmaşık vektör şekilleri oluşturmanıza olanak sağlar. Kalem aracını, oluşturduğunuz şeklin herhangi bir noktasından fazladan çizgi çizmek için kullanabilirsiniz.</li><li><strong>Yerleşik Yorum Yapma, Düzenleme ve Paylaşma</strong> Figma tasarım aracında, bir ekip oluşturabilir ve her ekip üyesinin projelerinizle neler yapabileceğini seçebilirsiniz: yalnızca onları görüntüleyebilir veya düzenleyebilirsiniz. Ekip üyelerinin tasarımı nasıl güncellediklerini veya gerçek zamanlı olarak değiştirdiklerini de izleyebilirsiniz.</li></ul><h2 id="Baslarken"><a href="#Baslarken" class="headerlink" title="Başlarken"></a>Başlarken</h2><p>Figma’yı nasıl kullanacağımızı öğrenirken yardım aldığımız videoları siz de aşağıdan izleyebilirsiniz.</p><iframe src="https://www.youtube.com/embed/6Id4INKEwb8" frameborder="0" style="overflow:hidden;height:400px;width:100%;" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><iframe src="https://www.youtube.com/embed/PaPIsyO1t3Q" frameborder="0" style="overflow:hidden;height:400px;width:100%;" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><p>Kaynaklar : <a href="https://sendpulse.com/blog/figma-design-tool" target="_blank" rel="noopener">SendPulse</a>, <a href="https://webdesign.tutsplus.com/articles/what-is-figma--cms-32272" target="_blank" rel="noopener">tuts+</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Figma Nedir?, Figma’nın Özellikleri, Başlarken&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="atagulalan" scheme="https://wepod.github.io/tags/atagulalan/"/>
    
  </entry>
  
  <entry>
    <title>EcmaScript6 ile Gelen Değişiklikler</title>
    <link href="https://wepod.github.io/blog/es6/"/>
    <id>https://wepod.github.io/blog/es6/</id>
    <published>2019-12-01T22:14:56.000Z</published>
    <updated>2020-04-09T19:59:54.776Z</updated>
    
    <content type="html"><![CDATA[<p>EcmaScript Nedir?</p><a id="more"></a><h2 id="EcmaScript-Nedir"><a href="#EcmaScript-Nedir" class="headerlink" title="EcmaScript Nedir ?"></a>EcmaScript Nedir ?</h2><p>Zaman içerisinde JavaScript birçok evrim geçirdi. İlk zamanlarda Javascript EcmaScript ismini almıştı. Artık EcmaScript JavaScript’in kurallarını belirleyen standart haline geldi.<br>EcmaScript6 Haziran 2015`te yayınlandı. EcmaScript6 ile birlikte kod yazmayı kolaylaştıran birçok yenilik geldi.</p><h3 id="Const-ve-Let"><a href="#Const-ve-Let" class="headerlink" title="Const ve Let"></a>Const ve Let</h3><p>EcmaScript2015 `te değişkenleri sadece var ile tanımlayabiliyorduk. EcmaScript6 ile gelen yenilikler ile <strong>const</strong> ve <strong>let</strong> aracılığı ile değişkenlerimizi tanımlayabiliriz.</p><pre><code>const PI = 3.141593let name=&quot;Serdar&quot;</code></pre><h3 id="Block-Scope-and-Variables-and-Functions"><a href="#Block-Scope-and-Variables-and-Functions" class="headerlink" title="Block Scope and Variables and Functions"></a>Block Scope and Variables and Functions</h3><p>EcmaScript6’den önce değişkenler fonksiyon scoped`tu. EcmaScript6 ile birlikte gelen güncelleme ile let ve const ile tanımlanan değişkenler <strong>blok scope</strong> oldu.</p><h3 id="Arrow-Functions"><a href="#Arrow-Functions" class="headerlink" title="Arrow Functions"></a>Arrow Functions</h3><p>EcmaScript6 ile birlikte fonksiyon tanımına yeni bir sözdizimi getirildi. Artık daha kısa bir <strong>sözdizimi</strong> ile <strong>fonksiyon</strong> tanımlayabiliriz.</p><p><code>hello = () =&gt; { return &quot;Hello World!&quot;; }</code></p><h3 id="Varsayilan-Fonksiyon-Parametleri"><a href="#Varsayilan-Fonksiyon-Parametleri" class="headerlink" title="Varsayılan Fonksiyon Parametleri"></a>Varsayılan Fonksiyon Parametleri</h3><p>EcmaScript6 ile gelen özelliklerden bir taneside artık fonksiyonlarda <strong>varsayılan parametler</strong> kullanabiliriz.</p><pre><code>function multiply(a, b = 1) {  return a * b;}console.log(multiply(5, 2));// expected output: 10console.log(multiply(5));// expected output: 5</code></pre><h3 id="Class-sozdizimi"><a href="#Class-sozdizimi" class="headerlink" title="Class sözdizimi"></a>Class sözdizimi</h3><p>ES6 ile gelen yeniliklerden bir taneside class sözdizimi. Java , C++ , C# dillerinde olduğu gibi <strong>class</strong> anahtar kelimesini kullanarak sınıf oluşturabiliyoruz.</p><pre><code>class Polygon {  constructor(height, width) {    this.area = height * width;  }}console.log(new Polygon(4,3).area);// expected output: 12</code></pre><h3 id="Kalitim"><a href="#Kalitim" class="headerlink" title="Kalıtım"></a>Kalıtım</h3><p>EcmaScript6 ile gelen yenilikle birlikte diğer dillerde olduğu gibi (Java,C#,C++) <strong>extends</strong> anahtar kelimesi kullanılarak kalıtım yapılabilir.</p><pre><code>class Animal {  constructor(name) {    this.name = name;  }  speak() {    console.log(this.name + &apos; makes a noise.&apos;);  }}class Dog extends Animal {  speak() {    console.log(this.name + &apos; barks.&apos;);  }}</code></pre><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>JavaScript asenkron çalışan bir programlama dilidir. EcmaScript6dan önce callback fonksiyonları ile asenkron fonksiyonları yönetiyorduk. EcmaScript6 ile birlikte asenkron fonksiyonlar <strong>promise</strong> sözdizimi ile yönetilmeye başladı.</p><pre><code>new Promise(function(resolve, reject) { ... });</code></pre><h3 id="Destructing"><a href="#Destructing" class="headerlink" title="Destructing"></a>Destructing</h3><p>EcmaScript6 ile birlikte <strong>Destructing</strong> özelliği de gelmiştir. Destructing sayesinde dizileri ve objeleri daha kolay bir şekilde parçalara ayırabiliyoruz. Bu sayede daha okunabilir kod yazabiliriz.</p><pre><code>var a, b, rest;[a, b] = [10, 20];console.log(a);// expected output: 10console.log(b);// expected output: 20[a, b, ...rest] = [10, 20, 30, 40, 50];console.log(rest);// expected output: [30,40,50]</code></pre><h3 id="Template-Literal"><a href="#Template-Literal" class="headerlink" title="Template Literal"></a>Template Literal</h3><p>Template literals stringleri deklarasyon etmek için yeni bir yol sağlıyor. <strong>``</strong> (backstick) içersine yazdığınız <strong>${}</strong> sayesinde stringler üzerinde istediğiniz işlemleri yapabilirsiniz.</p><pre><code>`string text``string text line 1 string text line 2``string text ${expression} string text`tag `string text ${expression} string text`</code></pre><h3 id="Find"><a href="#Find" class="headerlink" title="Find()"></a>Find()</h3><p><strong>Array.Find()</strong> methodu test fonksiyonunu karşılayan ilk elamanı döndürür.</p><pre><code>const array1 = [5, 12, 8, 130, 44];const found = array1.find(element =&gt; element &gt; 10);</code></pre><h3 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex()"></a>findIndex()</h3><p><strong>Array.FindIndex()</strong> methodu test fonksiyonunu karşılayan ilk elamanının index değerini döndürür.</p><pre><code>arr.findIndex(callback[, thisArg])</code></pre><p>Kaynaklar : <a href="https://developer.mozilla.org/tr/docs/Web/JavaScript" target="_blank" rel="noopener">JavaScript - MDN - Mozilla</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;EcmaScript Nedir?&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="stunali" scheme="https://wepod.github.io/tags/stunali/"/>
    
  </entry>
  
  <entry>
    <title>Prettier Nedir?</title>
    <link href="https://wepod.github.io/blog/Prettier-Nedir/"/>
    <id>https://wepod.github.io/blog/Prettier-Nedir/</id>
    <published>2019-11-27T11:40:44.000Z</published>
    <updated>2020-04-09T19:59:54.772Z</updated>
    
    <content type="html"><![CDATA[<p>Prettier nedir? Standartın önemi nedir? Temiz kod yaklaşımı.</p><a id="more"></a><h3 id="Prettier-Nedir"><a href="#Prettier-Nedir" class="headerlink" title="Prettier Nedir?"></a>Prettier Nedir?</h3><p>Prettier, aşağıdakileri destekleyen bir kod formatlayıcısıdır:</p><ul><li>JavaScript, including ES2017</li><li>JSX</li><li>Angular</li><li>Vue</li><li>Flow</li><li>TypeScript</li><li>CSS, Less, and SCSS</li><li>HTML</li><li>JSON</li><li>GraphQL</li><li>Markdown, including GFM and MDX</li><li>YAML</li></ul><blockquote><p>Prettier, Tüm orijinal stilleri kaldırır ve gönderilen tüm kodların tutarlı bir stilde uyumlu olmasını sağlar. Yani kodunuzu alır, satır uzunluğunu hesaba katarak sıfırdan yazdırır.</p></blockquote><p>Örneğin aşağıdaki kod bloğunu inceleyelim:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo(arg1, arg2, arg3, arg4);</span><br></pre></td></tr></table></figure><p>Bu blok, tek bir satırda okunabilir. Bu yüzden stillendirmeye ihtiyacı yok. Ancak aşağıdaki kodda bu ihtiyacın doğduğunu görüyoruz:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo(reallyLongArg(), omgSoManyParameters(), IShouldRefactorThis(), isThereSeriouslyAnotherOne());</span><br></pre></td></tr></table></figure><p>Bu blok çok uzun olduğundan bunu ayırmamız gerekiyor. Prettier, sizin için bu şekilde yeniden yazıyor:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">foo(</span><br><span class="line">  reallyLongArg(),</span><br><span class="line">  omgSoManyParameters(),</span><br><span class="line">  IShouldRefactorThis(),</span><br><span class="line">  isThereSeriouslyAnotherOne()</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>Prettier, kod tabanınızın tamamında tutarlı bir kod stili (örn. AST’yi etkilemeyecek kod formatı) uygular.</p><h3 id="Standartin-Onemi"><a href="#Standartin-Onemi" class="headerlink" title="Standartın Önemi"></a>Standartın Önemi</h3><p>Standartın önemini bir örnek ile açıklayabilirim:</p><iframe style="width:100%;height: 630px;" height="630" scrolling="no" title="Standard-agnostic clock" src="https://codepen.io/siddhant-k-code/embed/OJJGNLJ?height=627&theme-id=light&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true">  See the Pen <a href="https://codepen.io/siddhant-k-code/pen/OJJGNLJ" target="_blank" rel="noopener">Standard-agnostic clock</a> by Siddhant Khare  (<a href="https://codepen.io/siddhant-k-code" target="_blank" rel="noopener">@siddhant-k-code</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</iframe><p>Gördüğünüz gibi, saat okumak gibi basit bir iş, standart olmadığında bir eziyete dönüşüyor. Kod için de aynı, başka birinin standartlara uymayan kodunu okuduğunuz zaman, buna alışmak zaman alıyor. Zaman ise, bildiğiniz gibi, projelerdeki en önemli kavram.</p><h3 id="Ozgurluk"><a href="#Ozgurluk" class="headerlink" title="Özgürlük"></a>Özgürlük</h3><p>Prettier, aslında istediğiniz şekilde kod yazmayı kolaylaştırıyor, çünkü daha sonra anında doğru bir şekilde formatlıyor. Böylece takımınızla birlikte, birleşik bir kod yazabiliyorsunuz.</p><p>Noktalı virgül yazmayı umursamıyor musunuz? Aşağıdakini yazın, Prettier sizin için zaten formatlıyor.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  var x = 5</span><br><span class="line">  var y = 6</span><br><span class="line">  var z = 7</span><br><span class="line">  return x + y + z</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Bir takımda çalışırken sürtünmeyi azaltmak çok önemli. Bu sorun, özellikle büyük takımlarda gerçekleşiyor. Tamamen sürtünmeden kaçınmak imkansız, ancak daha iyi çalışmayı kolaylaştırmak için Prettier gibi araçlardan faydalanabilirsiniz.</p><p>Kaynaklar: <a href="https://prettier.io/docs/en/index.html" target="_blank" rel="noopener">Prettier Docs</a> <a href="https://jlongster.com/A-Prettier-Formatter" target="_blank" rel="noopener">James Long</a> <a href="https://codepen.io/siddhant-k-code/pen/OJJGNLJ" target="_blank" rel="noopener">Siddhant Khare</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Prettier nedir? Standartın önemi nedir? Temiz kod yaklaşımı.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="atagulalan" scheme="https://wepod.github.io/tags/atagulalan/"/>
    
  </entry>
  
  <entry>
    <title>Öğrenme Teorileri</title>
    <link href="https://wepod.github.io/blog/Ogrenme-Teorileri/"/>
    <id>https://wepod.github.io/blog/Ogrenme-Teorileri/</id>
    <published>2019-11-27T10:06:44.000Z</published>
    <updated>2020-04-09T19:59:54.772Z</updated>
    
    <content type="html"><![CDATA[<p>Öğrenme teorileri nedir? Çocuğun daha hızlı ve iyi anlamasını nasıl sağlayabiliriz?</p><a id="more"></a><h3 id="Teknoloji-ile-Ogrenme"><a href="#Teknoloji-ile-Ogrenme" class="headerlink" title="Teknoloji ile Öğrenme"></a>Teknoloji ile Öğrenme</h3><p>Öğrenme, bireyin olgunlaşma düzeyine göre, çevresi ile etkileşimi sonucunda kişide yaşantı ürünü oluşan ve kalıcı olan davranış değişmesidir.</p><p>ABD’deki Texas Üniversitesinde Philips tarafından yapılan araştırma sonuçlarına göre insanlar; okuduklarının %10’unu, görüp işittiklerinin <strong>%50</strong>’sini, işittiklerinin <strong>%20</strong>’sini, söylediklerinin <strong>%70</strong>’ini, gördüklerinin <strong>%30</strong>’unu yapıp, söylediklerinin <strong><em>%90</em></strong>’ını hatırlamaktadırlar. Zaman faktörü sabit tutularak elde edilen bu oranlar, sınıf içinde çok ortamlı öğretme durumunun düzenlenmesi gerektiğini göstermektedir. Çoklu ortamlı öğretme durumunun gerçekleşmesi ise bilgisayar destekli eğitim ile mümkün olabilmektedir.</p><p>Teknoloji, bilimi kullanarak günlük hayatımızdaki işleri daha hızlı ve güvenli yapmak için kullanılan etmenleri ifade eder. Çamaşır ve bulaşık makineleri nasıl gündelik işleri kolaylaştırıyor ise, teknoloji ile öğrenim de öğrenmeyi kolaylaştıracak ve hızlandıracaktır. Buna örnek olarak akıllı tahtalar, projeksiyon cihazları, elektronik destek sistemleri verilebilir.</p><p>Teknoloji, öğrencinin bilgiye ulaşımını kolaylaştırmış ve <strong>eğitim kalitesini</strong> arttırmıştır.</p><p><img src="/blog/Ogrenme-Teorileri/tpib.png" alt="Teknolojik Pedagojik İçerik Bilgisi (TPİB)" title="Teknolojik Pedagojik İçerik Bilgisi (TPİB)"></p><p>Teknolojik Pedagojik İçerik Bilgisi (TPİB), içerik, pedagoji ve teknolojinin öğretim sürecindeki <strong>kesişim</strong> yeridir. TPİB’in amacı belli bir <em>konunun</em> (içerik), <em>teknolojiyi</em> kullanarak (teknoloji) <em>nasıl öğretileceği</em> (pedagoji) konusunda öğretmenlere yardımcı olmaktır. Çarpım tablosunun (içerik) teknoloji ile (teknoloji) nasıl daha iyi öğretileceği (pedagoji) TPİB’ ne örnektir.</p><h3 id="Ogrenme-Teorileri"><a href="#Ogrenme-Teorileri" class="headerlink" title="Öğrenme Teorileri"></a>Öğrenme Teorileri</h3><p>İnsanların nasıl öğrendiğine ve nasıl öğretileceğine dair çok fazla teori geliştirilmiştir. </p><blockquote><p>Teorilerin çoğaltılması bilime yararlıdır. Çünkü tek bir teori egemenliği eleştiri gücünü azaltır, tek bir teorinin egemenliği bireyin özgür gelişimini tehlikeye sokar. Düşünce tarihi, bilimin içine işleyerek tek tek her teorinin geliştirilmesinde kullanılmıştır.</p></blockquote><h4 id="Davranisci-Ogrenme"><a href="#Davranisci-Ogrenme" class="headerlink" title="Davranışçı Öğrenme"></a>Davranışçı Öğrenme</h4><p>Davranışçılar; öğrenmenin gerçekleşmesinin yani istenilen davranışları oluşturmanın, organizmaya dışarıdan gerekli uyarıcıların verilmesi ile gerçekleşeceğini, bunun da bir <strong>etki-tepki</strong> olduğunu açıklamışlardır. Asıl ilgi dışsal çevrenin (öğretim ortamlarının, materyallerinin ve stratejilerinin) planlanması üzerine yoğunlaşmaktadır.</p><p>Davranışçı öğretim teorisine göre şartlı tepki yoluyla öğrenme olduğu savunulur ve bu öğrenmede pekiştiricilerin (ödül veya ceza) nasıl kullanılacağı üzerinde durulur. Uygun öğrenme şartları hazırlandığında ve uyarıcı-tepki arasında sağlam bir bağ kurulduğunda <em>“Her öğrenci öğrenir”</em> ilkesi savunulur.</p><p>Davranışçı öğrenme teorisinin öğretim ilkelerinde yaparak öğrenme esastır ve pekiştiriciler önemli bir yer tutar. Kalıcılık ise tekrar ile sağlanır. İlk öğrenilenler, daha sonra öğrenilenleri etkiler; benzer bilgilerin öğrenimini kolaylaştırır. Eğer öğretilecek bilgi ve davranış çok fazla veya karmaşık ise, analiz yapıldıktan sonra bir <strong>öğretim planı</strong> yapılmalı ve <strong>kademeli</strong> olarak (ardışık sırayla) öğretilmelidir.</p><h4 id="Bilissel-Ogrenme"><a href="#Bilissel-Ogrenme" class="headerlink" title="Bilişsel Öğrenme"></a>Bilişsel Öğrenme</h4><p>Bilişsel öğrenme teorilerinde, öğrenme, kişinin davranımda bulunma kapasitesinin gelişmesidir.</p><p>Bellekteki bilginin değişmesi üzerine odaklaşan bilişselci psikologlar öğrenmenin doğrudan dışarıdan gözlenemeyen içsel bir zihinsel etkinlik olduğuna inanırlar. Öğrenme üzerine çalışan bilişselci psikologlar ise problem çözme, hatırlama gibi gözlenemeyen <em>zihinsel</em> etkinliklerle ilgilenirler.</p><p>Aynı probleme farklı cevaplar verilmesi bu ilkeyle açıklanabilir. Davranışları belirleyen nesnel gerçeklik değil, öznel gerçekliktir. Çevre ve durumlar aynı olsa dahi, problemin çözümü, bu problemin kişinin <strong><em>bilincinde nasıl anlaşıldığıyla</em></strong> ilgilidir.</p><p>Bilişselci yaklaşımda teknolojinin kullanılmasını şu şekilde açıklanabilir; <strong>Bilgisayar, birey için bir bilişsel rehber durumundadır</strong>. Var olan bilgileri bireye sunar ve bireyin gerçekleştirdiği işlemler doğrultusunda yönlendirme yapar. Bireyin öğrenmesi bu karşılıklı etkileşim sonucunda gerçekleşir. Bireyin hazır bulunuşluluk seviyesine göre ilerleme olduğu için bilgisayar programları bilişselci yaklaşıma uygun olarak düşünülebilir.</p><h4 id="Yapisalci-Ogrenme"><a href="#Yapisalci-Ogrenme" class="headerlink" title="Yapısalcı Öğrenme"></a>Yapısalcı Öğrenme</h4><p>Yapılandırmacı öğrenme toplumun değişen ihtiyaçlarını karşılamak için eğitimin yeniden yapılandırılmasının gereğini içeren görüşlerine dayandırılmaktadır. Yapılandırmacılığı yine Dewey gibi geleneksel eğitime karşı çıkan ve eğitimi hayata hazırlık olarak değil, eğitimin yaşamın kendisi için olduğunu savunan <em>J.J.Rousseau</em>’nun görüşüne de bağlantılı olduğunu savunulmaktadır.</p><p>Yapılandırmacı görüş, kişinin daha önceden benimsediği bilgileri, <strong>yeni problemler üzerinde uygulaması için yapılandırması</strong> prensibine dayalıdır. Yani bilgiler salt halde kullanılamaz, yeni problemlerin çözümü için yapılandırılarak kullanılır.</p><p>Yapılandırmacılığa ilişkin varsayımlarını şu şekilde belirlemiştir:</p><ul><li>Bilgi deneyimlerle yapılandırılır.</li><li>Öğrenme, dünyanın kişisel bir yorumudur.</li><li>Öğrenme, deneyimlere bağlı olarak geliştirilen aktif bir anlamlandırma sürecidir.</li><li>Kavramsal gelişim; anlamların paylaşılmasından, çoklu bakış açılarının paylaşılmasından ve içsel yansımalarımızın işbirlikçi öğrenmeye dönüşmesinden kaynaklanmaktadır.</li><li>Öğrenme gerçek durumlara göre belirlenmelidir; değerlendirme ayrı bir etkinlik olarak değil, hedeflerle bir bütün olarak yapılmalıdır.</li></ul><h5 id="Kaynaklar"><a href="#Kaynaklar" class="headerlink" title="Kaynaklar"></a>Kaynaklar</h5><ul><li>Bell‐Gredler, M.E., Learning and instruction: Theory into practice</li><li>Yalın, H.İ., Öğretim Teknolojileri ve Materyal Geliştirme</li><li>Yürütücü, A., Bilişim Toplumunda İlköğretim Sürecindeki Eğitim Teknolojileri</li><li>Durak, G., Algoritma Konusunda Geliştirilen “Programlama Mantığı Öğretici-P.M.Ö” Yazılımının Öğrenci Başarısına Etkisi</li><li>Duman, B., Öğrenme- Öğretme Kuramları ve Süreç Temelli Öğretim</li><li>Merrill, M.D., Construction and instructional design.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Öğrenme teorileri nedir? Çocuğun daha hızlı ve iyi anlamasını nasıl sağlayabiliriz?&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="atagulalan" scheme="https://wepod.github.io/tags/atagulalan/"/>
    
  </entry>
  
  <entry>
    <title>Styled Components</title>
    <link href="https://wepod.github.io/blog/Styled-Components/"/>
    <id>https://wepod.github.io/blog/Styled-Components/</id>
    <published>2019-11-25T23:27:22.000Z</published>
    <updated>2020-04-09T19:59:54.776Z</updated>
    
    <content type="html"><![CDATA[<p>Styled Components Nedir?, Styled Components Oluşturma, Biz Neden Tercih Ettik?</p><a id="more"></a><h4 id="Styled-Components-Nedir"><a href="#Styled-Components-Nedir" class="headerlink" title="Styled Components Nedir?"></a>Styled Components Nedir?</h4><p>Styled Components bizi uzun ve gittikçe karışan CSS kodlarından kurtaran, HTML elementlerini fonksiyonel stillendirmemizi sağlayan ve en önemlisi içerisinde JavaScript kodları kullanmamızı sağlayan bir teknolojidir. Geleneksel stil yazma metodunun dışına çıkarak, temasal ve işlevsel stil bileşenleri (components) oluşturmamızı sağlar.</p><h4 id="Styled-Components-Olusturma"><a href="#Styled-Components-Olusturma" class="headerlink" title="Styled Components Oluşturma"></a>Styled Components Oluşturma</h4><p>Bileşen oluşturmak çok basittir. Önce Styled Components’i yüklememiz gerekiyor. Aşağıdaki şekilde yüklüyoruz.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install styled-components@beta</span><br></pre></td></tr></table></figure><p>Ardından bir stilli bileşen oluşturmak aşağıdaki kod parçası kadar kolay.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import stil from &apos;styled-components&apos;;</span><br><span class="line"></span><br><span class="line">const Title = stil.h1`</span><br><span class="line">  color: red;</span><br><span class="line">`;</span><br></pre></td></tr></table></figure><p>Bu şekilde Title adında kırmızı bir h1 bileşeni oluşturmuş olduk.</p><p>JavaScript kodlarını aşağıdaki gibi kolaylıkla CSS içine ekleyebiliyoruz.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const Button = stil.button`</span><br><span class="line">  color: $&#123;props =&gt; props.theme.fg&#125;;</span><br><span class="line">  border: 2px solid $&#123;props =&gt; props.theme.fg&#125;;</span><br><span class="line">  background: $&#123;props =&gt; props.theme.bg&#125;;</span><br><span class="line"></span><br><span class="line">  font-size: 1em;</span><br><span class="line">  margin: 1em;</span><br><span class="line">  padding: 0.25em 1em;</span><br><span class="line">  border-radius: 3px;</span><br><span class="line">`;</span><br></pre></td></tr></table></figure><p>Bu şekilde Props’lara bağlı dinamik bir bileşen yapısını CSS içinde oluşturmuş olduk.</p><h4 id="Biz-Neden-Styled-Components-Kullanmayi-Tercih-Ettik"><a href="#Biz-Neden-Styled-Components-Kullanmayi-Tercih-Ettik" class="headerlink" title="Biz Neden Styled-Components Kullanmayı Tercih Ettik?"></a>Biz Neden Styled-Components Kullanmayı Tercih Ettik?</h4><p>Cevabı çok basit; kolaylık ve rahatlık. CSS içerisinde JavaScript kodu yazabilmemiz ve server-side rendering özelliğini desteklemesi nedeniyle, bu yöntemi projemizde kullanmayı tercih ediyoruz. Styled-Components, stylesheet rehydration ile eşzamanlı server-side rendering’i destekler. Aşağıdaki kıyaslama görseli de seçimimizin ne kadar doğru olduğunu kanıtlar niteliktedir.<br><img src="/blog/Styled-Components/styledcomponents.jpeg" alt="Styled Components Vs Others" title="Styled Components Kıyaslaması"></p><p>Kaynaklar : <a href="https://www.styled-components.com/" target="_blank" rel="noopener">styled-components</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Styled Components Nedir?, Styled Components Oluşturma, Biz Neden Tercih Ettik?&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="oguzturker8" scheme="https://wepod.github.io/tags/oguzturker8/"/>
    
  </entry>
  
  <entry>
    <title>POD | Ön Rapor</title>
    <link href="https://wepod.github.io/blog/Ikinci-Is-Paketi/"/>
    <id>https://wepod.github.io/blog/Ikinci-Is-Paketi/</id>
    <published>2019-11-25T22:34:26.000Z</published>
    <updated>2020-04-09T19:59:54.768Z</updated>
    
    <content type="html"><![CDATA[<p>POD Projesi, 2. İş Paketi, Ön Rapor</p><a id="more"></a><p>Düzgün görüntülenmiyorsa <a href="https://docs.google.com/document/d/e/2PACX-1vQuXSVGo5UgDetQEZEm9eG5Pm4yqGNA8whSHKVq7NvNKcXGk6heyJQd_MBGQ9u5_fY_abtKHf1sSquY/pub?embedded=true" target="_blank" rel="noopener">buraya tıklayın</a></p><iframe src="https://docs.google.com/document/d/e/2PACX-1vQuXSVGo5UgDetQEZEm9eG5Pm4yqGNA8whSHKVq7NvNKcXGk6heyJQd_MBGQ9u5_fY_abtKHf1sSquY/pub?embedded=true" style="overflow:hidden;height:9200px;width:100%;"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;POD Projesi, 2. İş Paketi, Ön Rapor&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="atagulalan" scheme="https://wepod.github.io/tags/atagulalan/"/>
    
      <category term="oguzturker8" scheme="https://wepod.github.io/tags/oguzturker8/"/>
    
      <category term="stunali" scheme="https://wepod.github.io/tags/stunali/"/>
    
  </entry>
  
  <entry>
    <title>POD | Tübitak 2209-A</title>
    <link href="https://wepod.github.io/blog/2209A-Tubitak/"/>
    <id>https://wepod.github.io/blog/2209A-Tubitak/</id>
    <published>2019-11-25T22:14:56.000Z</published>
    <updated>2020-04-09T19:59:54.764Z</updated>
    
    <content type="html"><![CDATA[<p>POD Projesi, 1. İş Paketi, Tübitak 2209-A</p><a id="more"></a><p>Düzgün görüntülenmiyorsa <a href="https://docs.google.com/document/d/e/2PACX-1vQLU0lVmXSCa2M0Nj-8iCnFXRWS9ArRRKQpNKZGBmisFOkN-1GfsGmC3-Hi6YGHUw/pub?embedded=true" target="_blank" rel="noopener">buraya tıklayın</a></p><iframe src="https://docs.google.com/document/d/e/2PACX-1vQLU0lVmXSCa2M0Nj-8iCnFXRWS9ArRRKQpNKZGBmisFOkN-1GfsGmC3-Hi6YGHUw/pub?embedded=true" frameborder="0" style="overflow:hidden;height:5600px;width:100%;"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;POD Projesi, 1. İş Paketi, Tübitak 2209-A&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="atagulalan" scheme="https://wepod.github.io/tags/atagulalan/"/>
    
      <category term="oguzturker8" scheme="https://wepod.github.io/tags/oguzturker8/"/>
    
      <category term="stunali" scheme="https://wepod.github.io/tags/stunali/"/>
    
  </entry>
  
  <entry>
    <title>Kullanacağımız Teknolojiler</title>
    <link href="https://wepod.github.io/blog/Kullanacagimiz-Teknolojiler/"/>
    <id>https://wepod.github.io/blog/Kullanacagimiz-Teknolojiler/</id>
    <published>2019-11-25T21:41:19.000Z</published>
    <updated>2020-04-09T19:59:54.772Z</updated>
    
    <content type="html"><![CDATA[<p>Teknoloji Seçimi, Ön Yüz, Sunucu Tarafı, Teknolojiler Hakkında</p><a id="more"></a><h4 id="Teknoloji-Secimi"><a href="#Teknoloji-Secimi" class="headerlink" title="Teknoloji Seçimi"></a>Teknoloji Seçimi</h4><p>Projemiz, bir web projesi olduğundan ön yüz tarafında kullanılabilecek teknolojiler sınırlı. Arka yüz tarafında ise sadece kullanıcı bilgileri tutulacağından, kompleks frameworkler yerine daha basit frameworkler kullanmayı planlıyoruz. Projemizin <strong>PWA</strong> olması gerektiğini düşünüyoruz. Projemizin tek bir dil üzerinden yazılması ile kodun, hangi yüzde çalışıldığına bakmadan, tüm proje üyeleri tarafından kolayca anlaşılacağını düşünüyoruz.</p><h4 id="On-Yuz-icin"><a href="#On-Yuz-icin" class="headerlink" title="Ön Yüz için"></a>Ön Yüz için</h4><ul><li><strong>HTML</strong> (Hyper Text Markup Language),</li><li><strong>CSS</strong> (Cascading Style Sheets),</li><li><strong>Vue.js</strong> (sunucu tarafında render etmek için <strong>Nuxt.js</strong>)</li></ul><h4 id="Sunucu-Tarafi-Icin"><a href="#Sunucu-Tarafi-Icin" class="headerlink" title="Sunucu Tarafı İçin"></a>Sunucu Tarafı İçin</h4><ul><li><a href="https://wepod.github.io/blog/Node-Js/"><strong>Node.js</strong></a>,</li><li><strong>MongoDB</strong></li></ul><h4 id="Kullanici-Deneyimi-Icin"><a href="#Kullanici-Deneyimi-Icin" class="headerlink" title="Kullanıcı Deneyimi İçin"></a>Kullanıcı Deneyimi İçin</h4><ul><li><a href="https://wepod.github.io/blog/Progressive-Web-App/"><strong>PWA</strong></a> (Progressive Web Apps), ,</li><li><a href="https://wepod.github.io/blog/Betik-Dili/"><strong>Betik Dili</strong></a>,</li><li><strong>Adobe Illustrator</strong>,<br>teknolojilerini kullanmaya karar verdik.</li></ul><h4 id="Kullanilacak-Teknolojiler-Hakkinda"><a href="#Kullanilacak-Teknolojiler-Hakkinda" class="headerlink" title="Kullanılacak Teknolojiler Hakkında"></a>Kullanılacak Teknolojiler Hakkında</h4><ul><li>Her tarayıcının okuyup anlayabildiği HTML standardı ile <strong>platform bağımsız</strong> bir uygulama geliştireceğiz. Böylelikle hangi tarayıcıdan veya hangi platformdan girdiğinize bakmadan, Chrome, Yandex Browser, Firefox, Opera,Safari gibi web tarayıcılarının okuyup anladığı bir uygulama tasarlayacağız.</li><li>CSS bir siteyi renklendirmeyi ve biçimlendirmeyi sağlar. HTML iskeletinin üzerine giydirilen bir kıyafet gibi düşünülebilir.</li><li>Vue.js kullanıcı arayüzleri ve tek sayfa uygulamalar inşa etmek için kullanılan <strong>MVC modeli</strong> açık kaynak Javascript framework’üdür. Bu çıktıyı sunucu tarafında çalıştırmak (render etmek) için Nuxt.js kullanacağız.</li><li>Ayrıca projemizi PWA yapacağız. Böylelikle projemiz her platformda (telefon, bilgisayar, tablet) kullanabilir olacak ve <strong>internet gerektirmeyecektir</strong>. Aynı bir uygulama gibi bilgisayarınıza indirebildiğiniz, ya da web üzerinden oynayabildiğiniz bir uygulama olacak.</li><li>Arka yüzde ise Node.js (Chrome v8 Javascript Engine) kullanarak <strong>server-side</strong> tarafında yine Javascript kodlarımızı çalıştıracağız. Böylece hem ön yüzde, hem de arka yüzde Javascript yazarak birden fazla dil karmaşıklığının önüne geçeceğiz.</li><li>Veritabanı olarak MongoDB kullanacağız. MongoDB, 2009 yılında geliştirilmiş açık kaynak kodlu bir <strong>NoSQL</strong> veritabanıdır.</li><li>Projeyi gerçekleştirirken kendi sözdizimi yapımızı oluşturacağız. Böylece kodu kopyalama, paylaşma gibi işlevler yapılmasının yanı sıra, satır satır yorumlayarak <strong>her aşamayı ekranda gösterebileceğiz</strong>.</li><li>Bölümleri, ekranları tasarlamak için Adobe Illustrator kullanıyoruz. Bu program, tasarladığımız bölümleri ve görselleri <strong>SVG</strong> formatında çıktı veriyor. Böylece hangi cihazda çalıştırıldığına bakmadan, görselleri yeniden boyutlandırdığımızda bulanık gözükmüyor ve görselleri eklerken sorun yaşamıyoruz.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Teknoloji Seçimi, Ön Yüz, Sunucu Tarafı, Teknolojiler Hakkında&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="oguzturker8" scheme="https://wepod.github.io/tags/oguzturker8/"/>
    
  </entry>
  
  <entry>
    <title>Betik Dili</title>
    <link href="https://wepod.github.io/blog/Betik-Dili/"/>
    <id>https://wepod.github.io/blog/Betik-Dili/</id>
    <published>2019-11-25T17:01:13.000Z</published>
    <updated>2020-04-09T19:59:54.764Z</updated>
    
    <content type="html"><![CDATA[<p>Betik Dili Nedir?, POD İçinde Betik Dili, Betik Dili Operasyon Kodları</p><a id="more"></a><h4 id="Betik-Dili-Nedir"><a href="#Betik-Dili-Nedir" class="headerlink" title="Betik Dili Nedir?"></a>Betik Dili Nedir?</h4><p>Betik Dili (Scripting/Script Language), <strong>betik yorumlamak</strong> için yazılmış özel çalışma-zamanı sistemlerinin (run-time environment) yorumlayabileceği programlama dilleridir. Diğer programlama dilleri ile yazılan kodlar makine koduna çevrilip çıkan program doğrudan çalıştırılırken betik kodları <strong>interpreter</strong> tarafından doğrudan okunur ve yorumlanarak işlemler interpreter’ın kendisi tarafından yapılır. Betik dillerinin en önemli farkı, derleme adımına ihtiyaç duymamasıdır. Bu diller, yorumlanarak çalışır.</p><p>Örneğin, normalde, bir C programının çalıştırmadan önce derlenmesi gerekirken JavaScript veya PHP gibi bir betik dili derlenmeden çalışabilir.</p><h4 id="POD-Icinde-Betik-Dili"><a href="#POD-Icinde-Betik-Dili" class="headerlink" title="POD İçinde Betik Dili"></a>POD İçinde Betik Dili</h4><p>Projeyi tasarlarken üzerinde durduğumuz en önemli şey, bu projenin, çocuklara programlama ve algoritma öğreten diğer hiçbir projeye benzememesini sağlamaktır. Bunun için diğer projelerdeki gibi iç içe geçen bloklar kullanmak yerine daha sade, problemi kısıtlı kaynaklarla çözmeye zorlayan bir betik dili geliştirmeye karar verdik. Projede kullanılacak olan betik dilinin ilk prototiplerini yapmış bulunmaktayız.</p><p>Aşağıdaki şekilde giriş olarak verilen her iki sayıyı karşılaştıran, eşitse çıkışa koyan bir program yazılmıştır. Bunun dışında sıfırları eleyen, her sayıyı sekizle çarpan, her iki sayıyı tersten yazan, sadece tek sayıları bulan programlar da yazmak mümkündür.</p><p><img src="/blog/Betik-Dili/betikdili.jpg" alt="Prototikte Bulunan Betik Dili" title="Prototikte Bulunan Betik Dili"></p><h4 id="Betik-Dili-Operasyon-Kodlari"><a href="#Betik-Dili-Operasyon-Kodlari" class="headerlink" title="Betik Dili Operasyon Kodları"></a>Betik Dili Operasyon Kodları</h4><p>Aşağıda, betik dilinden proje içinde kullanılan bazı <strong>operasyon kodu</strong> örnekleri verilmiştir:</p><p><strong>CME</strong> : Come. JMP veya JMZ’den dönüş için kullanılır.<br><strong>INP</strong> : Input. Girdi dizisinden bir eleman almak için kullanılır.<br><strong>OUT</strong> : Output. Çıktı dizisine eldeki elemanı vermek için kullanılır.<br><strong>CPY</strong> : Copy. Eldeki elemanı bellek kısmına kopyalamak için kullanılır.<br><strong>GET</strong> : Get. Bellekteki elemanı ele kopyalamak için kullanılır.<br><strong>SUB</strong> : Substract. Eldeki elemandan bellekteki elemanı çıkartmak için kullanılır.<br><strong>ADD</strong> : Add. Eldeki eleman ile bellekteki elemanı toplamak için kullanılır.<br><strong>JMP</strong> : Jump. Aynı etikete sahip CME satırına koşulsuz atlamak için kullanılır.<br><strong>JPZ</strong> : Jump If Zero. Aynı etikete sahip CME satırına eldeki eleman sıfır olmak koşuluyla atlamak için kullanılır.</p><p>Kaynaklar : <a href="https://tr.wikipedia.org/wiki/Betik_dili" target="_blank" rel="noopener">Wikipedia</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Betik Dili Nedir?, POD İçinde Betik Dili, Betik Dili Operasyon Kodları&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="oguzturker8" scheme="https://wepod.github.io/tags/oguzturker8/"/>
    
  </entry>
  
  <entry>
    <title>Node.Js</title>
    <link href="https://wepod.github.io/blog/Node-Js/"/>
    <id>https://wepod.github.io/blog/Node-Js/</id>
    <published>2019-11-24T11:30:00.000Z</published>
    <updated>2020-04-09T19:59:54.772Z</updated>
    
    <content type="html"><![CDATA[<p>Neden Node.js, npm, Node modülleri</p><a id="more"></a><p>Node.js JavaScript ekosisteminin en çok kullanılan frameworklerinden biridir.<br>Node.js’in gelmesi ile birlikte artık JavaScript yazarak backend geliştirme olanağına sahip olduk.<br>Bundan önce JavaScript kodlarını sadece <strong>tarayıcı tarafında</strong> çalıştırabiliyorduk.<br>Node.js <strong>“Chrome’un v8 JavaScript Engine”</strong> kullanarak <strong>server-side</strong> tarafında JavaScript kodlarımızı çalıştırır.<br>Bu motor JavaScript kodlarımızı alır ve makine koduna dönüştürür.</p><h2 id="Neden-Node-js"><a href="#Neden-Node-js" class="headerlink" title="Neden Node.js"></a>Neden Node.js</h2><p>Node.js olaya dayalı, asenkron fonksiyonlar kullanır ve bu onu <strong>hızlı</strong> ve <strong>verimli</strong> yapar.<br>Node.js dünyanın en büyük açık kaynak kodlu (npm) paketlerine sahiptir. Bu bize <strong>modülerlik</strong> sağlar.</p><h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><p>Npm bir <strong>paket yöneticisidir.</strong> Bu paket yöneticisini kullanarak problemlerinizi çözebilirsiniz. Açık kaynak yazılımdır.<br>Bu paket yöneticisi <strong>hızlı</strong> ve <strong>verimli</strong> kod yazmayı sağlar.</p><h2 id="Node-modulleri"><a href="#Node-modulleri" class="headerlink" title="Node modülleri"></a>Node modülleri</h2><p>Node modülleri, başka kodu etkilemeyen, yeniden kullanılabilir kod bloklarıdır. Kendi modüllerinizi yazabilir ve çeşitli uygulamalarda kullanabilirsiniz.<br>Node.js, daha fazla kurulum yapmadan kullanabileceğiniz bir dizi yerleşik modüle sahiptir.</p><blockquote><p>Bir node modülü çıkartmak için yapmanız gereken tek şey <code>module.exports</code> kullanmaktır. Bu kodu, farklı bir projede veye kod bloğunda <code>require</code> yardımıyla çalıştırabilirsiniz.</p></blockquote><p>Bu sistem projede modülerlik sağlar, projenin maliyetini düşürür ve daha hızlı çalışmanıza olanak tanır.</p><blockquote><p>Günümüzde Linkedin Node.js teknolojisine geçmiştir. Node.js’e geçişten sonra <strong>sunucu maaliyeti 1/10</strong> düşmüştür. Node.js kullanan bir başka firma da <strong>PayPal</strong>‘dır.</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Neden Node.js, npm, Node modülleri&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="stunali" scheme="https://wepod.github.io/tags/stunali/"/>
    
  </entry>
  
  <entry>
    <title>Progressive Web Apps</title>
    <link href="https://wepod.github.io/blog/Progressive-Web-App/"/>
    <id>https://wepod.github.io/blog/Progressive-Web-App/</id>
    <published>2019-10-08T23:03:13.000Z</published>
    <updated>2020-04-09T19:59:54.772Z</updated>
    
    <content type="html"><![CDATA[<p>Progressive Web Apps Nedir?, Nasıl Çalışır?, Özellikleri Nedir?</p><a id="more"></a><h4 id="Progressive-Web-Apss-PWA"><a href="#Progressive-Web-Apss-PWA" class="headerlink" title="Progressive Web Apss (PWA)"></a>Progressive Web Apss (PWA)</h4><p>Progressive Web App kısaca PWA, web sitelerinin görünümünü ve kullanıcı deneyimini, mobil uygulamalarla benzer seviyeye getirilen uygulamalara verilen isimdir. Bu yaklaşım ile tasarlanan web sitelerini mobil tarayıcıdan ziyaret ettiğinizde, sanki bir web sitesini değil bir mobil uygulamayı kullanıyormuş gibi bir deneyim yaşarsınız.</p><h4 id="PWA-Calisma-Mantigi"><a href="#PWA-Calisma-Mantigi" class="headerlink" title="PWA Çalışma Mantığı"></a>PWA Çalışma Mantığı</h4><p>PWA olarak tasarlanmış bir web sitesine mobil cihazlardaki güncel bir <strong>Chrome</strong> tarayıcı ile girdiğinizde, tarayıcı bu uygulamayı <strong>kısayol olarak ana ekranınıza eklemek ister misiniz</strong> diye soruyor. Eğer kabul ederseniz web sitesi artık telefonunuzun ekranının tamamını kaplıyor ve normal bir mobil uygulama gibi çalışmaya başlıyor. Burada çalışan yine bir web sayfası, ancak gerek tasarımsal gerekse kullanıcı deneyimi açısından doğru dizayn edilmiş bir PWA’da bunu farketmeniz çok zor oluyor.</p><p>PWA’nın önemli bileşeni <strong>Service Worker</strong> ise web içeriğinin mobil cihaza yüklenmesini sağlar. Böylece telefonunuz internete bağlı olmasa bile uygulamayı açtığınızda siz telefona aktarılan tüm içeriği ziyaret edebilirsiniz.</p><p><img src="http://devnot.com/wp-content/uploads/2017/05/progressive-web-apps-1.png" alt="Aliexpress PWA Kullanımı" title="Aliexpress PWA Kullanımı"></p><h4 id="PWA-Ozellikleri"><a href="#PWA-Ozellikleri" class="headerlink" title="PWA Özellikleri"></a>PWA Özellikleri</h4><ul><li>Service Worker ile yavaş internet hızına rağmen hızlıca yüklenme</li><li>Bir uygulama gibi telefonun ekranında ikon koyabilme</li><li>Full Screen sayfa gösterimi ve Splash Screen</li><li>Push Notification gönderme</li><li>Service Worker’in gelişimi ile offline mode’da çalıştığı gibi yavaş bağlantıda da sorunsuz çalışma</li><li>Kullanıcıyı Google Play Store’a yönlendirmeden tarayıcı üzerinden ana ekran ikonu ekleme</li><li>Uygulama navigasyonunu ve uygulama etkileşimini kullanabilme</li><li>Cep telefonunuza sadece kısayol ikonu eklediği için mobil uygulamaları yüklerken karşılaştığımız yetersiz hafıza sorunu ile karşılaşmama</li></ul><p>Kaynaklar : <a href="https://medium.com/@atamanonur/desktop-ve-mobil-web-in-geleceği-progressive-web-apps-379f3f4514a9" target="_blank" rel="noopener">atamanonur</a>, <a href="http://devnot.com/2017/progressive-web-apps-pwa-nedir/" target="_blank" rel="noopener">devnot</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Progressive Web Apps Nedir?, Nasıl Çalışır?, Özellikleri Nedir?&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="oguzturker8" scheme="https://wepod.github.io/tags/oguzturker8/"/>
    
  </entry>
  
  <entry>
    <title>POD Nedir?</title>
    <link href="https://wepod.github.io/blog/Pod-Nedir/"/>
    <id>https://wepod.github.io/blog/Pod-Nedir/</id>
    <published>2019-09-30T21:23:49.000Z</published>
    <updated>2020-04-09T19:59:54.772Z</updated>
    
    <content type="html"><![CDATA[<p>Biz kimiz, amacımız ne ve neden bu kadar önemli?</p><a id="more"></a><p>Kocaeli Üniversitesi Bilgisayar Mühendisliği son sınıf öğrencileri olarak yapacak olduğumuz projenin amaçlarını, projede kullanılacak araçları ve projenin geliştirimini olabildiğince detaylı bir şekilde bu blogda paylaşmayı düşünüyoruz.</p><p>Bu proje, 4. sınıf öğrencileri <a href="https://github.com/atagulalan" target="_blank" rel="noopener">Ata Gülalan</a>, <a href="https://github.com/oguzturker8" target="_blank" rel="noopener">Oğuzhan Türker</a> ve <a href="https://github.com/fxy0" target="_blank" rel="noopener">Serdar Tunalı</a>, Araştırma Problemleri ve Bitirme Projesi dersleri kapsamında <a href="http://akademikpersonel.kocaeli.edu.tr/pinar.onaydurdu/" target="_blank" rel="noopener">Yar. Doç. Dr. Pınar ONAY DURDU</a> gözetmenliğinde yürütülecektir.</p><p>Bu projede temel amacımız, çocuklara algoritma öğreten bir yapı geliştirmek.</p><p>Bu projeyi web tarayıcı üzerinde gerçekleyerek çok daha büyük bir kitleyi hedefliyoruz. Son zamanlarda iyice yaygınlaşan <strong>PWA (Progressive Web Apps)</strong> kullanarak, internet olmasa dahi cep telefonları ve tabletlerde çalışır hale getirmeyi planlıyoruz. Böylece hareket halinde, uçakta veya internetin olmadığı herhangi bir yerde dahi uygulamayı kullanılabilir sağlayarak çocuklarımızın eğitimine katkı sağlamayı amaçlıyoruz.</p><h4 id="Neden-cocuklara-algoritma-ve-kodlama-ogretmek-onemli"><a href="#Neden-cocuklara-algoritma-ve-kodlama-ogretmek-onemli" class="headerlink" title="Neden çocuklara algoritma ve kodlama öğretmek önemli?"></a>Neden çocuklara algoritma ve kodlama öğretmek önemli?</h4><p>Gelecek, daha fazla yazılımcı bekliyor. Gün geçtikçe yazılımcılara olan ihtiyaç artıyor ve <strong>yaratıcı düşünce</strong> gerektirmeyen çoğu meslek insanların elinden alınıp, bu işi daha iyi yapacak robotlara veriliyor.</p><p>Her ne kadar bu değişimden haz almasak da, bu değişim geleceğin bir parçası. Bu değişime çocuklarımızı hazırlamamız gerekiyor.</p><p>Bu proje ile çocuklara şu becerileri kazanmalarında yardımcı olacağız:</p><ul><li>Algoritmik düşünce</li><li>Mantıksal tasarım</li><li>Kritik karar alma</li><li>Yaratıcı düşünce</li><li>Süreklilik</li><li>Sabır</li><li>Kalıpların dışında düşünme</li><li>Farklı açılardan bakma</li></ul><p>Umarım bizim bu projeye başlarken hissettiğimiz gibi, siz de geleceğe umutla bakarsınız.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Biz kimiz, amacımız ne ve neden bu kadar önemli?&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="atagulalan" scheme="https://wepod.github.io/tags/atagulalan/"/>
    
  </entry>
  
</feed>
